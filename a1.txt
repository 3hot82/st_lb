from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types import InlineKeyboardMarkup

def get_media_pagination(game_id: int, current_index: int, total_count: int, media_type: str) -> InlineKeyboardMarkup:
    """–ö–Ω–æ–ø–∫–∏ –¥–ª—è –ª–∏—Å—Ç–∞–Ω–∏—è –∫–∞—Ä—Ç–∏–Ω–æ–∫ (–í–µ—Ä—Ö–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ)"""
    builder = InlineKeyboardBuilder()
    
    if current_index > -1:
        builder.button(text="‚¨ÖÔ∏è", callback_data=f"media_{game_id}_{current_index - 1}")
    
    if current_index == -1:
        label = "–û–±–ª–æ–∂–∫–∞"
        action = "ignore"
    else:
        label = f"–°–∫—Ä–∏–Ω {current_index + 1}/{total_count}"
        action = f"media_{game_id}_-1"

    builder.button(text=f"üñº {label}", callback_data=action)

    if current_index < total_count - 1:
        builder.button(text="‚û°Ô∏è", callback_data=f"media_{game_id}_{current_index + 1}")
    
    width = 1
    if current_index > -1: width += 1
    if current_index < total_count - 1: width += 1
    
    builder.adjust(width)
    return builder.as_markup()

# === –ò–ó–ú–ï–ù–ï–ù–ò–ï –ó–î–ï–°–¨ ===
def get_info_pagination(game_id: int, current_page: int, total_pages: int, image_msg_id: int = 0) -> InlineKeyboardMarkup:
    """
    –ö–Ω–æ–ø–∫–∏ –¥–ª—è —Ç–µ–∫—Å—Ç–∞.
    image_msg_id: ID —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∫–∞—Ä—Ç–∏–Ω–∫–æ–π, –∫–æ—Ç–æ—Ä–æ–µ –≤–∏—Å–∏—Ç –≤—ã—à–µ.
    """
    builder = InlineKeyboardBuilder()
    
    # –ú—ã –¥–æ–±–∞–≤–ª—è–µ–º image_msg_id –≤ callback_data –∫–Ω–æ–ø–æ–∫ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏, 
    # —á—Ç–æ–±—ã –Ω–µ –ø–æ—Ç–µ—Ä—è—Ç—å –µ–≥–æ –ø—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü —Ç–µ–∫—Å—Ç–∞.
    # –§–æ—Ä–º–∞—Ç: info_GAMEID_PAGE_IMGID
    
    if total_pages == 2:
        if current_page == 1:
            builder.button(text="üõ† –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∏ –î–µ—Ç–∞–ª–∏ ‚û°Ô∏è", callback_data=f"info_{game_id}_2_{image_msg_id}")
        else:
            builder.button(text="‚¨ÖÔ∏è –û–± –∏–≥—Ä–µ", callback_data=f"info_{game_id}_1_{image_msg_id}")
    else:
        if current_page > 1:
            builder.button(text="‚¨ÖÔ∏è", callback_data=f"info_{game_id}_{current_page - 1}_{image_msg_id}")
        builder.button(text=f"{current_page}/{total_pages}", callback_data="ignore")
        if current_page < total_pages:
            builder.button(text="‚û°Ô∏è", callback_data=f"info_{game_id}_{current_page + 1}_{image_msg_id}")
    
    builder.adjust(1)
    
    row_btns = []
    
    # === –ì–õ–ê–í–ù–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï ===
    # –ü–µ—Ä–µ–¥–∞–µ–º image_msg_id –≤ –∫–Ω–æ–ø–∫—É –∞—á–∏–≤–æ–∫: ach_GAMEID_INDEX_IMGID
    row_btns.append(
        InlineKeyboardBuilder().button(text="üèÜ –ê—á–∏–≤–∫–∏", callback_data=f"ach_{game_id}_0_{image_msg_id}").as_markup().inline_keyboard[0][0]
    )
    
    row_btns.append(
        InlineKeyboardBuilder().button(text="üõí Steam", url=f"https://store.steampowered.com/app/{game_id}/").as_markup().inline_keyboard[0][0]
    )
    
    builder.row(*row_btns)
    
    return builder.as_markup()# –§–∞–π–ª: steam_bot/keyboards/main_menu.py

from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder

def get_main_menu() -> ReplyKeyboardMarkup:
    builder = ReplyKeyboardBuilder()
    
    # –û—Å–Ω–æ–≤–Ω—ã–µ –∫–Ω–æ–ø–∫–∏
    builder.row(
        KeyboardButton(text="üë§ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å"),
        KeyboardButton(text="üéÆ –ü–æ–∏—Å–∫ –∏–≥—Ä")
    )
    builder.row(
        KeyboardButton(text="üé≤ –°–ª—É—á–∞–π–Ω–∞—è –∏–≥—Ä–∞"), # –ú–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–æ–∑–∂–µ
        KeyboardButton(text="‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏")
    )
    
    return builder.as_markup(resize_keyboard=True)

def get_onboarding_kb() -> InlineKeyboardMarkup:
    """–ö–Ω–æ–ø–∫–∞ –ø–æ–º–æ—â–∏ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏"""
    builder = InlineKeyboardBuilder()
    builder.button(text="‚ùì –ì–¥–µ –≤–∑—è—Ç—å —Å—Å—ã–ª–∫—É?", callback_data="help_steam_link")
    return builder.as_markup()from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types import InlineKeyboardMarkup

def get_achievements_pagination(game_id: int, current_index: int, total_count: int) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    # 1. –ö–Ω–æ–ø–∫–∞ –ù–∞–∑–∞–¥ (–∏–ª–∏ –≤ –∫–æ–Ω–µ—Ü, –µ—Å–ª–∏ –º—ã –≤ –Ω–∞—á–∞–ª–µ)
    if current_index > 0:
        builder.button(text="‚¨ÖÔ∏è", callback_data=f"ach_{game_id}_{current_index - 1}")
    else:
        builder.button(text="üîö", callback_data=f"ach_{game_id}_{total_count - 1}")

    # 2. –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä
    builder.button(text=f"{current_index + 1}/{total_count}", callback_data="ignore")

    # 3. –ö–Ω–æ–ø–∫–∞ –í–ø–µ—Ä–µ–¥ (–∏–ª–∏ –≤ –Ω–∞—á–∞–ª–æ, –µ—Å–ª–∏ –º—ã –≤ –∫–æ–Ω—Ü–µ)
    if current_index < total_count - 1:
        builder.button(text="‚û°Ô∏è", callback_data=f"ach_{game_id}_{current_index + 1}")
    else:
        builder.button(text="üîÑ", callback_data=f"ach_{game_id}_0")
    
    builder.adjust(3)
    
    # 4. –ö–Ω–æ–ø–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –∫ –∫–∞—Ä—Ç–æ—á–∫–µ –∏–≥—Ä—ã
    builder.row(
        # –≠—Ç–∞ –∫–Ω–æ–ø–∫–∞ –≤—ã–∑–æ–≤–µ—Ç view_game_, –∫–æ—Ç–æ—Ä—ã–π –≤–µ—Ä–Ω–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏–≥—Ä—ã
        InlineKeyboardBuilder().button(text="üîô –ö –∫–∞—Ä—Ç–æ—á–∫–µ –∏–≥—Ä—ã", callback_data=f"view_game_{game_id}").as_markup().inline_keyboard[0][0]
    )
    
    return builder.as_markup()# –§–∞–π–ª: steam_bot/keyboards/game_card.py

from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types import InlineKeyboardMarkup

def get_game_card_kb(game_id: int, has_achievements: bool, has_ru_locale: bool) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    # 1. –°—Å—ã–ª–∫–∞ –Ω–∞ –º–∞–≥–∞–∑–∏–Ω (–≤—Å–µ–≥–¥–∞ –ø–æ–ª–µ–∑–Ω–∞)
    builder.button(text="üõí Steam Store", url=f"https://store.steampowered.com/app/{game_id}/")
    
    # 2. –ê—á–∏–≤–∫–∏ (–µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å)
    if has_achievements:
        builder.button(text="üèÜ –ê—á–∏–≤–∫–∏", callback_data=f"achievements_{game_id}_page_1")
    
    # 3. –¢—Ä–µ–π–ª–µ—Ä—ã (–µ—Å–ª–∏ –µ—Å—Ç—å –≤ –±–∞–∑–µ, –Ω–æ –∫–Ω–æ–ø–∫—É –æ—Å—Ç–∞–≤–∏–º –≤—Å–µ–≥–¥–∞)
    builder.button(text="üìπ –¢—Ä–µ–π–ª–µ—Ä—ã", callback_data=f"trailers_{game_id}")
    
    # 4. –ï—Å–ª–∏ –Ω–µ—Ç —Ä—É—Å—Å–∫–æ–≥–æ –æ–ø–∏—Å–∞–Ω–∏—è - –∫–Ω–æ–ø–∫–∞ –æ–±–Ω–æ–≤–∏—Ç—å
    if not has_ru_locale:
        builder.button(text="üá∑üá∫ –ó–∞–≥—Ä—É–∑–∏—Ç—å RU", callback_data=f"update_ru_{game_id}")

    # –ö—Ä–∞—Å–∏–≤–∞—è —Å–µ—Ç–∫–∞: 1 –∫–Ω–æ–ø–∫–∞ (–º–∞–≥–∞–∑–∏–Ω), –ø–æ—Ç–æ–º –ø–æ 2 –≤ —Ä—è–¥
    builder.adjust(1, 2)
    return builder.as_markup()

def get_search_results_kb(games: list) -> InlineKeyboardMarkup:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –∫–Ω–æ–ø–æ–∫ —Å –Ω–∞–π–¥–µ–Ω–Ω—ã–º–∏ –∏–≥—Ä–∞–º–∏"""
    builder = InlineKeyboardBuilder()
    for game in games:
        # –í callback_data –∫–ª–∞–¥–µ–º ID –∏–≥—Ä—ã
        builder.button(text=f"üéÆ {game.name}", callback_data=f"view_game_{game.id}")
    
    builder.adjust(1)
    return builder.as_markup()import asyncio
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy import text

# –¢–≤–æ–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
DATABASE_URL = "postgresql+asyncpg://postgres:root@localhost/steam_bot_db"

async def check_game():
    engine = create_async_engine(DATABASE_URL, echo=False)
    
    print("üïµÔ∏è‚Äç‚ôÇÔ∏è –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö...")

    async with engine.begin() as conn:
        # 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ ID 70
        print("\n--- –ü–û–ò–°–ö –ü–û ID 1222140 ---")
        result = await conn.execute(text("SELECT id, name, reviews_total FROM games WHERE id = 1222140"))
        game = result.first()
        
        if game:
            print(f"‚úÖ –ò–ì–†–ê –ù–ê–ô–î–ï–ù–ê –ü–û ID!")
            print(f"üÜî ID: {game.id}")
            print(f"üìõ –ò–º—è –≤ –±–∞–∑–µ: '{game.name}'") # –í–∞–∂–Ω–æ: –∫–∞–≤—ã—á–∫–∏ –ø–æ–∫–∞–∂—É—Ç, –µ—Å—Ç—å –ª–∏ –ø—Ä–æ–±–µ–ª—ã
            print(f"üë• –û—Ç–∑—ã–≤–æ–≤: {game.reviews_total}")
        else:
            print("‚ùå –ò–≥—Ä—ã —Å ID 1222140 –ù–ï–¢ –≤ –±–∞–∑–µ.")

        # 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é (–≤–¥—Ä—É–≥ ID –¥—Ä—É–≥–æ–π –∏–ª–∏ –∏–º—è –∫—Ä–∏–≤–æ–µ)
        print("\n--- –ü–û–ò–°–ö –ü–û –ù–ê–ó–í–ê–ù–ò–Æ '%Half%Life%' ---")
        result = await conn.execute(text("SELECT id, name, reviews_total FROM games WHERE name ILIKE '%Half%Life%' ORDER BY reviews_total DESC LIMIT 10"))
        rows = result.all()
        
        if rows:
            for row in rows:
                print(f"üéÆ {row.name} (ID: {row.id}) - –û—Ç–∑—ã–≤–æ–≤: {row.reviews_total}")
        else:
            print("‚ùå –ù–∏—á–µ–≥–æ –ø–æ—Ö–æ–∂–µ–≥–æ –Ω–∞ Half-Life –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")

    await engine.dispose()

if __name__ == "__main__":
    asyncio.run(check_game())btn-profile = üë§ My Profile
btn-search = üéÆ Search Games
btn-random = üé≤ Random Game
btn-settings = ‚öôÔ∏è Settings
btn-back = üîô Back
btn-achievements = üèÜ Achievements
btn-store = üõí Steam Store

welcome = üëã <b>Hi! I'm Steam Explorer.</b>
    Type a game name to start.

welcome-back = üëã Welcome back, <b>{ $name }</b>!

search-prompt = ‚úçÔ∏è Just type the game name.
search-not-found = ‚ùå Nothing found for <b>'{ $query }'</b>.
search-found = üîé Found { $count } games. Choose one:

profile-info = üë§ <b>Your Profile:</b>
    üÜî Steam ID: <code>{ $steamid }</code>
    üåç Region: <b>{ $country }</b>

achievements-loading = ‚è≥ Loading achievements...
achievements-empty = ‚ùå No achievements found.
achievement-hidden = üîí <i>Hidden achievement.</i>
achievement-stat = üìä { $rarity }: { $emoji } <b>{ $percent }%</b> players

rarity-common = Common
rarity-rare = Rare
rarity-legendary = Legendary

err-load = ‚ö†Ô∏è Failed to load file.# –û–±—â–∏–µ –∫–Ω–æ–ø–∫–∏
btn-profile = üë§ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å
btn-search = üéÆ –ü–æ–∏—Å–∫ –∏–≥—Ä
btn-random = üé≤ –°–ª—É—á–∞–π–Ω–∞—è –∏–≥—Ä–∞
btn-settings = ‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏
btn-back = üîô –ù–∞–∑–∞–¥
btn-achievements = üèÜ –ê—á–∏–≤–∫–∏
btn-store = üõí Steam Store

# –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ
welcome = üëã <b>–ü—Ä–∏–≤–µ—Ç! –Ø Steam Explorer.</b>
    
    –Ø –ø–æ–º–æ–≥—É —Ç–µ–±–µ:
    üîπ –°–ª–µ–¥–∏—Ç—å –∑–∞ –∞—á–∏–≤–∫–∞–º–∏
    üîπ –ò—Å–∫–∞—Ç—å –∏–≥—Ä—ã
    üîπ –£–∑–Ω–∞—Ç—å –≤—Ä–µ–º—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è
    
    –ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –∏–ª–∏ –Ω–∞–ø–∏—à–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã.

welcome-back = üëã –° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º, <b>{ $name }</b>!

# –ü–æ–∏—Å–∫
search-prompt = ‚úçÔ∏è –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã –≤ —á–∞—Ç.
    <i>–ù–∞–ø—Ä–∏–º–µ—Ä: –í–µ–¥—å–º–∞–∫, CS2, Stalker</i>

search-not-found = ‚ùå –ü–æ –∑–∞–ø—Ä–æ—Å—É <b>'{ $query }'</b> –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.
search-found = üîé –ù–∞–π–¥–µ–Ω–æ –∏–≥—Ä: { $count }. –í—ã–±–µ—Ä–∏ –Ω—É–∂–Ω—É—é:

# –ü—Ä–æ—Ñ–∏–ª—å
profile-info = üë§ <b>–¢–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å:</b>
    üÜî Steam ID: <code>{ $steamid }</code>
    üåç –†–µ–≥–∏–æ–Ω: <b>{ $country }</b>
    
    –î–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤—å /refresh

# –ê—á–∏–≤–∫–∏
achievements-loading = ‚è≥ –ê—á–∏–≤–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ó–∞–≥—Ä—É–∂–∞—é –∏–∑ Steam...
achievements-empty = ‚ùå –£ —ç—Ç–æ–π –∏–≥—Ä—ã –Ω–µ—Ç –∞—á–∏–≤–æ–∫ –∏–ª–∏ –æ—à–∏–±–∫–∞ Steam.
achievement-hidden = üîí <i>–≠—Ç–æ —Å–∫—Ä—ã—Ç–æ–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ.</i>
achievement-stat = üìä { $rarity }: { $emoji } <b>{ $percent }%</b> –∏–≥—Ä–æ–∫–æ–≤

rarity-common = –û–±—ã—á–Ω–∞—è
rarity-rare = –†–µ–¥–∫–∞—è
rarity-legendary = –õ–µ–≥–µ–Ω–¥–∞—Ä–Ω–∞—è

# –û—à–∏–±–∫–∏
err-load = ‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª.from fluentogram import FluentTranslator, TranslatorHub
from fluentogram.resources import FluentResourceLoader

def create_translator_hub() -> TranslatorHub:
    """
    –°–æ–∑–¥–∞–µ—Ç –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç —Ö–∞–± –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–æ–≤.
    """
    loader = FluentResourceLoader("locales/{locale}")
    
    return TranslatorHub(
        # –°–ª–æ–≤–∞—Ä—å: "–∫–æ–¥ —è–∑—ã–∫–∞": ("—Å–ø–∏—Å–æ–∫", "—Ñ–∞–π–ª–æ–≤", "–ø–µ—Ä–µ–≤–æ–¥–∞")
        {"ru": ("ru", "messages.ftl"),
         "en": ("en", "messages.ftl")},
        
        # –û—Å–Ω–æ–≤–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫ (–µ—Å–ª–∏ —è–∑—ã–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω, –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —ç—Ç–æ—Ç)
        root_locale="ru" 
    )import aiohttp
from typing import Optional, Dict, List, Any
from config import conf

class SteamService:
    BASE_URL = "http://api.steampowered.com"
    STORE_URL = "https://store.steampowered.com/api"

    def __init__(self):
        self.api_key = conf.steam_api_key

    async def resolve_vanity_url(self, vanity_url: str) -> Optional[str]:
        clean_url = vanity_url.rstrip('/').split('/')[-1]
        if clean_url.isdigit() and len(clean_url) == 17:
            return clean_url

        url = f"{self.BASE_URL}/ISteamUser/ResolveVanityURL/v0001/"
        params = {"key": self.api_key, "vanityurl": clean_url}

        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params) as resp:
                if resp.status != 200: return None
                data = await resp.json()
                if data.get('response', {}).get('success') == 1:
                    return data['response']['steamid']
        return None

    async def get_player_summary(self, steam_id: str) -> Dict[str, Any]:
        url = f"{self.BASE_URL}/ISteamUser/GetPlayerSummaries/v0002/"
        params = {"key": self.api_key, "steamids": steam_id}
        
        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params) as resp:
                data = await resp.json()
                players = data.get('response', {}).get('players', [])
                return players[0] if players else {}

    async def get_owned_games(self, steam_id: str) -> Optional[List[Dict]]:
        url = f"{self.BASE_URL}/IPlayerService/GetOwnedGames/v0001/"
        params = {
            "key": self.api_key,
            "steamid": steam_id,
            "include_appinfo": 1,
            "include_played_free_games": 1
        }

        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params) as resp:
                if resp.status == 500: return None
                data = await resp.json()
        
        response = data.get('response', {})
        return response.get('games')

    async def get_game_price(self, app_id: int, country: str) -> Optional[str]:
        url = f"{self.STORE_URL}/appdetails"
        params = {
            "appids": app_id,
            "cc": country,
            "filters": "price_overview"
        }
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params) as resp:
                    if resp.status != 200: return None
                    data = await resp.json()
                    game_data = data.get(str(app_id), {})
                    if not game_data.get('success'): return None
                    
                    if game_data.get('data', {}).get('is_free'):
                        return "Free"
                        
                    price_data = game_data.get('data', {}).get('price_overview')
                    if not price_data: return None
                        
                    return price_data.get('final_formatted')
        except Exception as e:
            print(f"Error fetching price: {e}")
            return None

    # === –ù–û–í–´–ï –ú–ï–¢–û–î–´ –î–õ–Ø –ê–ß–ò–í–û–ö ===

    async def get_game_schema(self, app_id: int, language: str) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∞–µ—Ç —Å—Ö–µ–º—É –∞—á–∏–≤–æ–∫ (–∏–º–µ–Ω–∞, –æ–ø–∏—Å–∞–Ω–∏—è, –∏–∫–æ–Ω–∫–∏)"""
        url = f"{self.BASE_URL}/ISteamUserStats/GetSchemaForGame/v2/"
        params = {
            "key": self.api_key,
            "appid": app_id,
            "l": language # 'russian' –∏–ª–∏ 'english'
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params) as resp:
                if resp.status != 200: return {}
                data = await resp.json()
                
                # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å–ø–∏—Å–æ–∫ –≤ —Å–ª–æ–≤–∞—Ä—å {api_name: data} –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
                achievements = data.get('game', {}).get('availableGameStats', {}).get('achievements', [])
                return {ach['name']: ach for ach in achievements}

    async def get_global_achievement_percentages(self, app_id: int) -> Dict[str, float]:
        """–ü–æ–ª—É—á–∞–µ—Ç % –ø–æ–ª—É—á–µ–Ω–∏—è"""
        url = f"{self.BASE_URL}/ISteamUserStats/GetGlobalAchievementPercentagesForApp/v0002/"
        params = {"gameid": app_id}
        
        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params) as resp:
                if resp.status != 200: return {}
                data = await resp.json()
                
                stats = data.get('achievementpercentages', {}).get('achievements', [])
                return {s['name']: s['percent'] for s in stats}

steam_service = SteamService()import re

# –°–ª–æ–≤–∞—Ä—å —Ä–∞—Å–∫–ª–∞–¥–∫–∏
LAYOUT_MAPPING = {
    'q': '–π', 'w': '—Ü', 'e': '—É', 'r': '–∫', 't': '–µ', 'y': '–Ω', 'u': '–≥', 'i': '—à', 'o': '—â', 'p': '–∑', '[': '—Ö', ']': '—ä',
    'a': '—Ñ', 's': '—ã', 'd': '–≤', 'f': '–∞', 'g': '–ø', 'h': '—Ä', 'j': '–æ', 'k': '–ª', 'l': '–¥', ';': '–∂', "'": '—ç',
    'z': '—è', 'x': '—á', 'c': '—Å', 'v': '–º', 'b': '–∏', 'n': '—Ç', 'm': '—å', ',': '–±', '.': '—é',
    '–π': 'q', '—Ü': 'w', '—É': 'e', '–∫': 'r', '–µ': 't', '–Ω': 'y', '–≥': 'u', '—à': 'i', '—â': 'o', '–∑': 'p', '—Ö': '[', '—ä': ']',
    '—Ñ': 'a', '—ã': 's', '–≤': 'd', '–∞': 'f', '–ø': 'g', '—Ä': 'h', '–æ': 'j', '–ª': 'k', '–¥': 'l', '–∂': ';', '—ç': "'",
    '—è': 'z', '—á': 'x', '—Å': 'c', '–º': 'v', '–∏': 'b', '—Ç': 'n', '—å': 'm', '–±': ',', '—é': '.'
}

# –°–ª–µ–Ω–≥
ALIASES = {
    "—Ö–∞–ª—Ñ–∞": "Half-Life", "—Ö–ª": "Half-Life", "hl": "Half-Life", "hl2": "Half-Life 2",
    "–¥–æ—Ç–∞": "Dota 2", "–∫—Å": "Counter-Strike", "–∫—Å–≥–æ": "Counter-Strike 2",
    "cs": "Counter-Strike 2", "cs2": "Counter-Strike 2",
    "–≤–µ–¥—å–º–∞–∫": "The Witcher 3", "–≥—Ç–∞": "Grand Theft Auto V",
    "–ø–∞–±–≥": "PUBG", "pubg": "PUBG", "—Ç—É–Ω–¥—Ä–∞": "War Thunder",
    "—Å–∫–∞–π—Ä–∏–º": "Skyrim", "—Å–º—É—Ç–∞": "Smuta", "–≤–∞—Ä—Ñ—Ä–µ–π–º": "Warframe"
}

def fix_layout(text: str) -> str:
    return "".join(LAYOUT_MAPPING.get(char, char) for char in text.lower())

def normalize_roman_numerals(text: str) -> str:
    """–ú–µ–Ω—è–µ—Ç 'gta 5' –Ω–∞ 'gta v', 'civ 6' –Ω–∞ 'civ vi' –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –ø–æ–∏—Å–∫–∞"""
    # –ü—Ä–æ—Å—Ç–∞—è –∑–∞–º–µ–Ω–∞ –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö —Ü–∏—Ñ—Ä
    replacements = {
        r'\b1\b': 'I', r'\b2\b': 'II', r'\b3\b': 'III', r'\b4\b': 'IV', 
        r'\b5\b': 'V', r'\b6\b': 'VI', r'\b7\b': 'VII'
    }
    # –ú—ã –Ω–µ –º–µ–Ω—è–µ–º —Å–∞–º —Ç–µ–∫—Å—Ç –∑–∞–ø—Ä–æ—Å–∞ –∂–µ—Å—Ç–∫–æ, —ç—Ç–æ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
    # –í –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ –ª—É—á—à–µ –æ—Å—Ç–∞–≤–∏—Ç—å –∫–∞–∫ –µ—Å—Ç—å, —Ç–∞–∫ –∫–∞–∫ pg_trgm —Å–ø—Ä–∞–≤–∏—Ç—Å—è —Å–∞–º,
    # –Ω–æ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –ø–æ–∏—Å–∫–∞.
    return text

def clean_query(text: str) -> str:
    """
    –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞:
    1. –ù–∏–∂–Ω–∏–π —Ä–µ–≥–∏—Å—Ç—Ä.
    2. –ó–∞–º–µ–Ω–∞ —Å–ª–µ–Ω–≥–∞.
    3. –£–¥–∞–ª–µ–Ω–∏–µ –í–°–ï–• —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª–æ–≤ (–æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã –∏ —Ü–∏—Ñ—Ä—ã –∏ –ø—Ä–æ–±–µ–ª—ã).
    –≠—Ç–æ –ø–æ–∑–≤–æ–ª–∏—Ç –Ω–∞–π—Ç–∏ 'Half-Life' –ø–æ –∑–∞–ø—Ä–æ—Å—É 'half life'.
    """
    text = text.lower().strip()
    
    # 1. –°–ª–µ–Ω–≥
    if text in ALIASES:
        return ALIASES[text].lower()
    
    # 2. –£–¥–∞–ª—è–µ–º –º—É—Å–æ—Ä (‚Ñ¢, ¬Æ, :)
    text = text.replace("‚Ñ¢", "").replace("¬Æ", "").replace("¬©", "")
    
    # 3. –ó–∞–º–µ–Ω—è–µ–º –ª—é–±—ã–µ –∑–Ω–∞–∫–∏ –ø—Ä–µ–ø–∏–Ω–∞–Ω–∏—è –Ω–∞ –ø—Ä–æ–±–µ–ª—ã (half-life -> half life)
    # –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã, —Ü–∏—Ñ—Ä—ã –∏ –ø—Ä–æ–±–µ–ª—ã
    text = re.sub(r'[^a-z–∞-—è0-9\s]', ' ', text)
    
    # 4. –£–±–∏—Ä–∞–µ–º –¥–≤–æ–π–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã
    text = re.sub(r'\s+', ' ', text).strip()
    
    return textimport asyncio
import logging
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.dialects.postgresql import insert

from database.models.game import Achievement
from services.steam import steam_service

async def sync_game_achievements(session: AsyncSession, game_id: int) -> bool:
    """
    –°–∫–∞—á–∏–≤–∞–µ—Ç –∞—á–∏–≤–∫–∏ –∏–∑ Steam (EN + RU + –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞) –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤ –ë–î.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ –∞—á–∏–≤–∫–∏ –Ω–∞–π–¥–µ–Ω—ã –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã.
    """
    logging.info(f"üîÑ Syncing achievements for Game ID: {game_id}...")

    # 1. –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
    stats_task = steam_service.get_global_achievement_percentages(game_id)
    schema_en_task = steam_service.get_game_schema(game_id, "english")
    schema_ru_task = steam_service.get_game_schema(game_id, "russian")

    # –ñ–¥–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    stats, schema_en, schema_ru = await asyncio.gather(stats_task, schema_en_task, schema_ru_task)

    if not schema_en:
        logging.warning(f"‚ùå –ê—á–∏–≤–∫–∏ –¥–ª—è {game_id} –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ Steam.")
        return False

    achievements_to_insert = []

    # 2. –û–±—ä–µ–¥–∏–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ
    for api_name, data_en in schema_en.items():
        data_ru = schema_ru.get(api_name, {})
        
        # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ–Ω—Ç–∞
        raw_percent = stats.get(api_name, 0.0)
        try:
            percent = float(raw_percent)
        except (ValueError, TypeError):
            percent = 0.0
        
        icon_url = data_en.get('icon')
        
        locales = {
            "en": {
                "name": data_en.get('displayName'),
                "desc": data_en.get('description')
            },
            "ru": {
                "name": data_ru.get('displayName', data_en.get('displayName')),
                "desc": data_ru.get('description')
            }
        }

        is_hidden = data_en.get('hidden', 0) == 1

        ach_data = {
            "game_id": game_id,
            "api_name": api_name,
            "icon_url": icon_url,
            "global_percent": percent,
            "is_hidden": is_hidden,
            "locales": locales
        }
        achievements_to_insert.append(ach_data)

    if not achievements_to_insert:
        return False

    # 3. –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î (Mass Upsert)
    try:
        stmt = insert(Achievement).values(achievements_to_insert)
        
        update_stmt = stmt.on_conflict_do_update(
            constraint='uix_game_achievement',
            set_={
                "icon_url": stmt.excluded.icon_url,
                "global_percent": stmt.excluded.global_percent,
                "locales": stmt.excluded.locales,
                "is_hidden": stmt.excluded.is_hidden
            }
        )
        
        await session.execute(update_stmt)
        await session.commit()
        logging.info(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(achievements_to_insert)} –∞—á–∏–≤–æ–∫ –¥–ª—è {game_id}")
        return True
        
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∞—á–∏–≤–æ–∫: {e}")
        await session.rollback()
        return Falseaiofiles==25.1.0
aiogram==3.23.0
aiohappyeyeballs==2.6.1
aiohttp==3.13.2
aiosignal==1.4.0
aiounittest==1.5.0
alembic==1.17.2
annotated-types==0.7.0
APScheduler==3.11.2
asyncpg==0.31.0
attrs==25.4.0
babel==2.17.0
beautifulsoup4==4.14.3
black==25.12.0
certifi==2025.11.12
charset-normalizer==3.4.4
click==8.3.1
cloudscraper==1.2.71
colorlog==6.10.1
cryptg==0.5.2
fake-useragent==2.2.0
fluent-compiler==1.1
fluent.syntax==0.19.0
fluentogram==1.2.1
frozenlist==1.8.0
greenlet==3.3.0
howlongtobeatpy==1.0.19
idna==3.11
iniconfig==2.3.0
isort==7.0.0
kagglehub==0.3.13
librt==0.7.5
loguru==0.7.3
lxml==6.0.2
magic-filter==1.0.12
Mako==1.3.10
MarkupSafe==3.0.3
multidict==6.7.0
mypy==1.19.1
mypy_extensions==1.1.0
numpy==2.4.0
packaging==25.0
pandas==2.3.3
pathspec==0.12.1
pillow==12.0.0
platformdirs==4.5.1
playwright==1.57.0
pluggy==1.6.0
propcache==0.4.1
pyaes==1.6.1
pyasn1==0.6.1
pydantic==2.12.5
pydantic-settings==2.12.0
pydantic_core==2.41.5
pyee==13.0.0
Pygments==2.19.2
pyparsing==3.3.1
Pyrogram==2.0.106
PySocks==1.7.1
pytest==9.0.2
pytest-asyncio==1.3.0
python-dateutil==2.9.0.post0
python-dotenv==1.2.1
pytokens==0.3.0
pytz==2025.2
PyYAML==6.0.3
redis==7.1.0
requests==2.32.5
requests-toolbelt==1.0.0
rsa==4.9.1
six==1.17.0
soupsieve==2.8.1
SQLAlchemy==2.0.45
Telethon==1.42.0
TgCrypto==1.2.5
tqdm==4.67.1
typing-inspection==0.4.2
typing_extensions==4.15.0
tzdata==2025.3
tzlocal==5.3.1
urllib3==2.6.2
wrapt==2.0.1
yarl==1.22.0
yt-dlp==2025.12.8
import asyncio
from sqlalchemy import select
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

from config import conf
from database.models import Game

# ID –∏–≥—Ä—ã Detroit
TARGET_ID = 1222140 

async def inspect_media():
    engine = create_async_engine(conf.database_url, echo=False)
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∞–±—Ä–∏–∫—É —Å–µ—Å—Å–∏–π
    session_maker = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

    async with session_maker() as session:
        print(f"üîé –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–µ–¥–∏–∞ –¥–ª—è ID: {TARGET_ID}...\n")

        result = await session.execute(select(Game).where(Game.id == TARGET_ID))
        game = result.scalars().first()

        if not game:
            print("‚ùå –ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –±–∞–∑–µ.")
            return

        extra = game.extra_data or {}
        locales = game.locales or {}
        ru_data = locales.get('ru', {})

        # 1. –û–ë–õ–û–ñ–ö–ê
        print(f"üñº HEADER IMAGE (–û–±–ª–æ–∂–∫–∞):")
        print(f"   {ru_data.get('header_image')}")
        print("-" * 40)

        # 2. –°–ö–†–ò–ù–®–û–¢–´
        screenshots = extra.get('screenshots', [])
        print(f"üì∏ SCREENSHOTS (–í—Å–µ–≥–æ: {len(screenshots)}):")
        for i, url in enumerate(screenshots):
            print(f"   {i+1}. {url}")
        
        print("-" * 40)

        # 3. –í–ò–î–ï–û (–¢—Ä–µ–π–ª–µ—Ä—ã)
        movies = extra.get('movies', [])
        print(f"üé• MOVIES (–í—Å–µ–≥–æ: {len(movies)}):")
        if not movies:
            print("   (–°–ø–∏—Å–æ–∫ –ø—É—Å—Ç)")
        else:
            for i, url in enumerate(movies):
                print(f"   {i+1}. {url}")

    await engine.dispose()

if __name__ == "__main__":
    asyncio.run(inspect_media())import asyncio
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy import text
from database.models.base import Base
from config import conf
from database.models.game import Achievement 

async def recreate_table():
    engine = create_async_engine(conf.database_url, echo=True)
    async with engine.begin() as conn:
        print("üóë –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—É—é —Ç–∞–±–ª–∏—Ü—É achievements...")
        await conn.execute(text("DROP TABLE IF EXISTS achievements CASCADE;"))
        
        print("üÜï –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Ç–∞–±–ª–∏—Ü—É...")
        await conn.run_sync(Base.metadata.create_all)
        
        # === –Ø–í–ù–û–ï –°–û–ó–î–ê–ù–ò–ï –û–ì–†–ê–ù–ò–ß–ï–ù–ò–Ø ===
        print("üîí –î–æ–±–∞–≤–ª—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ...")
        # –ï—Å–ª–∏ SQLAlchemy –Ω–µ —Å–æ–∑–¥–∞–ª–∞ –µ–≥–æ —Å–∞–º–∞, —Å–æ–∑–¥–∞–¥–∏–º –≤—Ä—É—á–Ω—É—é
        await conn.execute(text("""
            DO $$
            BEGIN
                IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'uix_game_achievement') THEN
                    ALTER TABLE achievements ADD CONSTRAINT uix_game_achievement UNIQUE (game_id, api_name);
                END IF;
            END
            $$;
        """))
        
    print("‚úÖ –¢–∞–±–ª–∏—Ü–∞ achievements –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∞ –∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞!")
    await engine.dispose()

if __name__ == "__main__":
    asyncio.run(recreate_table())import asyncio
from sqlalchemy.ext.asyncio import create_async_engine
from database.models.base import Base
from database.models.user import User, UserLibrary
from config import conf

async def init_db():
    print("üöÄ –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π...")
    engine = create_async_engine(conf.database_url, echo=True)
    
    async with engine.begin() as conn:
        # –°–æ–∑–¥–∞—Å—Ç —Ç–∞–±–ª–∏—Ü—ã users –∏ user_library, –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç
        await conn.run_sync(Base.metadata.create_all)
        
    print("‚úÖ –¢–∞–±–ª–∏—Ü—ã —Å–æ–∑–¥–∞–Ω—ã!")
    await engine.dispose()

if __name__ == "__main__":
    asyncio.run(init_db())import os
from dotenv import load_dotenv
from dataclasses import dataclass

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ .env
load_dotenv()

@dataclass
class Config:
    bot_token: str
    steam_api_key: str
    database_url: str

def load_config() -> Config:
    return Config(
        bot_token=os.getenv("BOT_TOKEN"),
        steam_api_key=os.getenv("STEAM_API_KEY"),
        database_url=os.getenv("DATABASE_URL")
    )

# –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–æ–Ω—Ñ–∏–≥–∞, —á—Ç–æ–±—ã –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –µ–≥–æ –≤–µ–∑–¥–µ
conf = load_config()import asyncio
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy import text

DATABASE_URL = "postgresql+asyncpg://postgres:root@localhost/steam_bot_db"

async def fix_db():
    engine = create_async_engine(DATABASE_URL, echo=True)
    print("üîÑ –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ç–∞–±–ª–∏—Ü—ã games...")
    
    async with engine.begin() as conn:
        # –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ –∫–æ–ª–æ–Ω–∫–∏, –∫–æ—Ç–æ—Ä—ã—Ö –º–æ–∂–µ—Ç –Ω–µ —Ö–≤–∞—Ç–∞—Ç—å
        await conn.execute(text("ALTER TABLE games ADD COLUMN IF NOT EXISTS time_plus FLOAT DEFAULT 0;"))
        await conn.execute(text("ALTER TABLE games ADD COLUMN IF NOT EXISTS time_main FLOAT DEFAULT 0;"))
        await conn.execute(text("ALTER TABLE games ADD COLUMN IF NOT EXISTS time_100 FLOAT DEFAULT 0;"))
        await conn.execute(text("ALTER TABLE games ADD COLUMN IF NOT EXISTS hltb_id VARCHAR;"))
        
    print("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∞!")
    await engine.dispose()

if __name__ == "__main__":
    asyncio.run(fix_db())# –§–∞–π–ª: steam_bot/states/user_states.py

from aiogram.fsm.state import State, StatesGroup

class UserStates(StatesGroup):
    # –°–æ—Å—Ç–æ—è–Ω–∏–µ, –∫–æ–≥–¥–∞ –±–æ—Ç –∂–¥–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ Steam
    waiting_for_steam_link = State()
    
    # –°–æ—Å—Ç–æ—è–Ω–∏–µ, –∫–æ–≥–¥–∞ –±–æ—Ç –∂–¥–µ—Ç –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å (–µ—Å–ª–∏ –º—ã —Å–¥–µ–ª–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω—É—é –∫–Ω–æ–ø–∫—É "–ü–æ–∏—Å–∫")
    waiting_for_search = State()from typing import Callable, Dict, Any, Awaitable
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject, User
from fluentogram import TranslatorHub

from sqlalchemy.ext.asyncio import async_sessionmaker
from sqlalchemy import select
from database.models import User as DBUser

class TranslatorRunnerMiddleware(BaseMiddleware):
    def __init__(self, session_pool: async_sessionmaker, translator_hub: TranslatorHub):
        self.session_pool = session_pool
        self.translator_hub = translator_hub

    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any],
    ) -> Any:
        # 1. –ü–æ–ª—É—á–∞–µ–º —é–∑–µ—Ä–∞ —Ç–µ–ª–µ–≥—Ä–∞–º
        tg_user: User = data.get("event_from_user")
        if not tg_user:
            return await handler(event, data)

        lang_code = "ru" # –Ø–∑—ã–∫ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

        # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º –ë–î (–µ—Å—Ç—å –ª–∏ —É —é–∑–µ—Ä–∞ –≤—ã–±—Ä–∞–Ω–Ω—ã–π —è–∑—ã–∫)
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ç–¥–µ–ª—å–Ω—É—é —Å–µ—Å—Å–∏—é –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        async with self.session_pool() as session:
            result = await session.execute(select(DBUser).where(DBUser.telegram_id == tg_user.id))
            db_user = result.scalars().first()
            
            if db_user and db_user.language:
                lang_code = db_user.language
            elif tg_user.language_code:
                # –ï—Å–ª–∏ –≤ –ë–î –Ω–µ—Ç, –±–µ—Ä–µ–º –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –¢–µ–ª–µ–≥—Ä–∞–º–∞ (ru-RU -> ru)
                lang_code = tg_user.language_code.split("-")[0]

        # 3. –ü–æ–ª—É—á–∞–µ–º "—Ä–∞–Ω–Ω–µ—Ä" (–≥–æ—Ç–æ–≤—ã–π –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —è–∑—ã–∫–∞)
        # –ï—Å–ª–∏ —è–∑—ã–∫–∞ 'kz' –Ω–µ—Ç –≤ —Ö–∞–±–µ, fluentogram —Å–∞–º –æ—Ç–∫–∞—Ç–∏—Ç—Å—è –∫ root_locale (ru)
        data["i18n"] = self.translator_hub.get_translator_by_locale(lang_code)
        
        return await handler(event, data)# –§–∞–π–ª: steam_bot/middlewares/db_session.py

from typing import Callable, Awaitable, Dict, Any
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject
from sqlalchemy.ext.asyncio import async_sessionmaker

class DbSessionMiddleware(BaseMiddleware):
    def __init__(self, session_pool: async_sessionmaker):
        super().__init__()
        self.session_pool = session_pool

    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any],
    ) -> Any:
        # –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å–µ—Å—Å–∏—é –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∞–ø–¥–µ–π—Ç–∞ (—Å–æ–æ–±—â–µ–Ω–∏—è/–∫–Ω–æ–ø–∫–∏)
        async with self.session_pool() as session:
            # –ö–ª–∞–¥–µ–º —Å–µ—Å—Å–∏—é –≤ data, —á—Ç–æ–±—ã —Ö–µ–Ω–¥–ª–µ—Ä –º–æ–≥ –µ—ë –∑–∞–±—Ä–∞—Ç—å
            data["session"] = session
            # –ü–µ—Ä–µ–¥–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ö–µ–Ω–¥–ª–µ—Ä—É
            return await handler(event, data)# –§–∞–π–ª: steam_bot/main.py

import asyncio
import logging
import sys

from aiogram import Bot, Dispatcher
from config import conf
from database.core import session_maker
from middlewares.db_session import DbSessionMiddleware
from handlers import get_handlers_router

async def main():
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–æ–≤
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
        stream=sys.stdout
    )
    logger = logging.getLogger(__name__)

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    bot = Bot(token=conf.bot_token)
    dp = Dispatcher()

    # –ü–æ–¥–∫–ª—é—á–∞–µ–º Middleware (–ë–î)
    # –¢–µ–ø–µ—Ä—å –≤ –∫–∞–∂–¥—ã–π —Ö–µ–Ω–¥–ª–µ—Ä –±—É–¥–µ—Ç –ø—Ä–∏–ª–µ—Ç–∞—Ç—å –∞—Ä–≥—É–º–µ–Ω—Ç session
    dp.update.middleware(DbSessionMiddleware(session_pool=session_maker))

    # –ü–æ–¥–∫–ª—é—á–∞–µ–º –•–µ–Ω–¥–ª–µ—Ä—ã
    dp.include_router(get_handlers_router())

    logger.info("üöÄ –ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")
    
    # –£–¥–∞–ª—è–µ–º –≤–µ–±—Ö—É–∫–∏ (—á—Ç–æ–±—ã –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Å—Ç–∞—Ä—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è)
    await bot.delete_webhook(drop_pending_updates=True)
    
    # –ó–∞–ø—É—Å–∫
    try:
        await dp.start_polling(bot)
    finally:
        await bot.session.close()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("üõë –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤—Ä—É—á–Ω—É—é.")import asyncio
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy.dialects.postgresql import insert
from config import conf
from services.steam import steam_service
from database.models.game import Achievement, Game

# ID –∏–≥—Ä—ã (Detroit)
TARGET_APP_ID = 1222140 

async def update_achievements():
    print(f"üöÄ –ù–∞—á–∏–Ω–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É –∞—á–∏–≤–æ–∫ –¥–ª—è –∏–≥—Ä—ã ID: {TARGET_APP_ID}...")

    # 1. –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
    print("üì• –°–∫–∞—á–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ Steam API...")
    stats_task = steam_service.get_global_achievement_percentages(TARGET_APP_ID)
    schema_en_task = steam_service.get_game_schema(TARGET_APP_ID, "english")
    schema_ru_task = steam_service.get_game_schema(TARGET_APP_ID, "russian")

    stats, schema_en, schema_ru = await asyncio.gather(stats_task, schema_en_task, schema_ru_task)

    if not schema_en:
        print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ö–µ–º—É –∞—á–∏–≤–æ–∫.")
        return

    print(f"‚úÖ –ü–æ–ª—É—á–µ–Ω–æ –∞—á–∏–≤–æ–∫: {len(schema_en)}")
    
    achievements_to_insert = []

    # 2. –û–±—ä–µ–¥–∏–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ
    for api_name, data_en in schema_en.items():
        data_ru = schema_ru.get(api_name, {})
        
        # === –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –û–®–ò–ë–ö–ò ===
        # –Ø–≤–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –ø—Ä–æ—Ü–µ–Ω—Ç –≤ float, —Ç–∞–∫ –∫–∞–∫ API –º–æ–∂–µ—Ç –≤–µ—Ä–Ω—É—Ç—å —Å—Ç—Ä–æ–∫—É '6.9'
        raw_percent = stats.get(api_name, 0.0)
        try:
            percent = float(raw_percent)
        except (ValueError, TypeError):
            percent = 0.0
        
        # –ò–∫–æ–Ω–∫–∞ (–±–µ—Ä–µ–º –∏–∑ EN)
        icon_url = data_en.get('icon')
        
        # –õ–æ–∫–∞–ª–∏–∑–∞—Ü–∏—è
        locales = {
            "en": {
                "name": data_en.get('displayName'),
                "desc": data_en.get('description')
            },
            "ru": {
                "name": data_ru.get('displayName', data_en.get('displayName')),
                "desc": data_ru.get('description')
            }
        }

        is_hidden = data_en.get('hidden', 0) == 1

        ach_data = {
            "game_id": TARGET_APP_ID,
            "api_name": api_name,
            "icon_url": icon_url,
            "global_percent": percent, # –¢–µ–ø–µ—Ä—å —ç—Ç–æ —Ç–æ—á–Ω–æ —á–∏—Å–ª–æ
            "is_hidden": is_hidden,
            "locales": locales
        }
        achievements_to_insert.append(ach_data)

    # 3. –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
    engine = create_async_engine(conf.database_url, echo=False)
    
    async with engine.begin() as conn:
        # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ –∏–≥—Ä–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        await conn.execute(
            insert(Game).values(id=TARGET_APP_ID, name="Detroit: Become Human")
            .on_conflict_do_nothing()
        )

        print(f"üíæ –°–æ—Ö—Ä–∞–Ω—è–µ–º {len(achievements_to_insert)} –∑–∞–ø–∏—Å–µ–π –≤ –ë–î...")
        
        stmt = insert(Achievement).values(achievements_to_insert)
        
        # UPSERT
        update_stmt = stmt.on_conflict_do_update(
            constraint='uix_game_achievement',
            set_={
                "icon_url": stmt.excluded.icon_url,
                "global_percent": stmt.excluded.global_percent,
                "locales": stmt.excluded.locales,
                "is_hidden": stmt.excluded.is_hidden
            }
        )
        
        await conn.execute(update_stmt)
    
    print("üéâ –ì–æ—Ç–æ–≤–æ! –ê—á–∏–≤–∫–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã.")
    await engine.dispose()

if __name__ == "__main__":
    asyncio.run(update_achievements())from sqlalchemy import Column, BigInteger, String, Integer, Float, Boolean, JSON, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from .base import Base

class Game(Base):
    __tablename__ = "games"

    id = Column(BigInteger, primary_key=True)  # Steam AppID
    name = Column(String, index=True)
    
    # –≠–∫–æ–Ω–æ–º–∏–∫–∞ (–ë–∞–∑–æ–≤–∞—è –≤ USD)
    price_current = Column(Float, default=0.0)
    is_free = Column(Boolean, default=False)
    currency = Column(String, default="USD")

    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    reviews_total = Column(Integer, default=0)
    achievements_count = Column(Integer, default=0)
    release_date = Column(String, nullable=True)
    metacritic_score = Column(Integer, default=0)

    # HowLongToBeat
    time_main = Column(Float, default=0)
    time_plus = Column(Float, default=0)
    time_100 = Column(Float, default=0)
    hltb_id = Column(String, nullable=True)

    # JSON –¥–∞–Ω–Ω—ã–µ
    locales = Column(JSON, default={})
    extra_data = Column(JSON, default={})

    updated_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # –°–≤—è–∑–∏
    achievements = relationship("Achievement", back_populates="game", cascade="all, delete-orphan")
    price_alerts = relationship("PriceAlert", back_populates="game", cascade="all, delete-orphan")

class Achievement(Base):
    __tablename__ = "achievements"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    game_id = Column(BigInteger, ForeignKey("games.id"), index=True)
    
    api_name = Column(String)
    category = Column(String, default="base")
    locales = Column(JSON, default={})
    icon_url = Column(String)
    
    is_hidden = Column(Boolean, default=False)
    global_percent = Column(Float, default=0.0)

    game = relationship("Game", back_populates="achievements")

class PriceAlert(Base):
    __tablename__ = "price_alerts"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(BigInteger, index=True)
    game_id = Column(BigInteger, ForeignKey("games.id"))
    target_price = Column(Integer)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    game = relationship("Game", back_populates="price_alerts")

# –ù–û–í–ê–Ø –ú–û–î–ï–õ–¨ –î–õ–Ø –ö–≠–®–ê –¶–ï–ù
class GamePrice(Base):
    __tablename__ = "game_prices"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    game_id = Column(BigInteger, index=True)
    country_code = Column(String, index=True)
    price_fmt = Column(String) # –û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ü–µ–Ω–∞ (–Ω–∞–ø—Ä. "5 900‚Ç∏")
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())from sqlalchemy import Column, BigInteger, String, Integer, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from .base import Base

class User(Base):
    __tablename__ = "users"

    telegram_id = Column(BigInteger, primary_key=True)
    steam_id = Column(BigInteger, unique=True, nullable=True)
    
    username = Column(String, nullable=True)
    language = Column(String, default="ru")
    avatar_url = Column(String, nullable=True)
    
    # –ù–û–í–û–ï –ü–û–õ–ï
    country = Column(String, default="US") 
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # –°–≤—è–∑—å —Å –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π
    library = relationship("UserLibrary", back_populates="user", cascade="all, delete-orphan")

class UserLibrary(Base):
    __tablename__ = "user_library"

    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(BigInteger, ForeignKey("users.telegram_id"), index=True)
    game_id = Column(BigInteger, ForeignKey("games.id"), index=True)
    
    playtime_forever = Column(Integer, default=0) # –ú–∏–Ω—É—Ç—ã
    playtime_2weeks = Column(Integer, default=0)
    
    user = relationship("User", back_populates="library")from .base import Base
from .game import Game, Achievement, PriceAlert, GamePrice # <--- –î–æ–±–∞–≤–∏–ª–∏ GamePrice
from .user import User, UserLibrary

__all__ = [
    "Base",
    "Game",
    "Achievement",
    "PriceAlert",
    "GamePrice", # <--- –î–æ–±–∞–≤–∏–ª–∏ —Å—é–¥–∞
    "User",
    "UserLibrary"
]# –§–∞–π–ª: steam_bot/database/models/base.py

from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    """
    –ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –≤—Å–µ—Ö –º–æ–¥–µ–ª–µ–π SQLAlchemy.
    –ü–æ–∑–≤–æ–ª—è–µ—Ç –Ω–µ –ø–∏—Å–∞—Ç—å __tablename__ –∫–∞–∂–¥—ã–π —Ä–∞–∑ –≤—Ä—É—á–Ω—É—é (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ),
    –Ω–æ –º—ã –±—É–¥–µ–º –ø–∏—Å–∞—Ç—å —è–≤–Ω–æ –¥–ª—è –ø–æ—Ä—è–¥–∫–∞.
    """
    passfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from config import conf

# –°–æ–∑–¥–∞–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –¥–≤–∏–∂–æ–∫
# echo=False, —á—Ç–æ–±—ã –Ω–µ –∑–∞—Å–æ—Ä—è—Ç—å –∫–æ–Ω—Å–æ–ª—å SQL-–∑–∞–ø—Ä–æ—Å–∞–º–∏ (–ø–æ—Å—Ç–∞–≤—å True –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
engine = create_async_engine(conf.database_url, echo=False)

# –§–∞–±—Ä–∏–∫–∞ —Å–µ—Å—Å–∏–π. –ß–µ—Ä–µ–∑ –Ω–µ—ë –º—ã –±—É–¥–µ–º –ø–æ–ª—É—á–∞—Ç—å –¥–æ—Å—Ç—É–ø –∫ –ë–î –≤ —Ö–µ–Ω–¥–ª–µ—Ä–∞—Ö.
# expire_on_commit=False –≤–∞–∂–µ–Ω –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã.
session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def get_session() -> AsyncSession:
    """
    –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å–µ—Å—Å–∏–π –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è—Ö (–µ—Å–ª–∏ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è)
    –∏–ª–∏ –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞.
    """
    async with session_maker() as session:
        yield sessionfrom sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, delete
from database.models import User, UserLibrary, Game

class UserRepo:
    def __init__(self, session: AsyncSession):
        self.session = session

    async def get_user(self, telegram_id: int) -> User | None:
        result = await self.session.execute(select(User).where(User.telegram_id == telegram_id))
        return result.scalars().first()

    async def create_or_update(self, telegram_id: int, steam_id: int, username: str = None, avatar: str = None, country: str = None):
        """
        –°–æ–∑–¥–∞–µ—Ç –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
        country: –ö–æ–¥ —Å—Ç—Ä–∞–Ω—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'KZ', 'RU', 'US'). –ï—Å–ª–∏ None, –Ω–µ –æ–±–Ω–æ–≤–ª—è–µ–º.
        """
        user = await self.get_user(telegram_id)
        
        if not user:
            user = User(telegram_id=telegram_id, steam_id=steam_id)
            self.session.add(user)
        else:
            user.steam_id = steam_id
        
        if username: user.username = username
        if avatar: user.avatar_url = avatar
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç—Ä–∞–Ω—É, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–∞ –ø—Ä–∏—à–ª–∞ –∏–∑ Steam
        if country:
            user.country = country
        
        await self.session.commit()
        return user

    async def update_library(self, telegram_id: int, games_data: list):
        """
        –û–±–Ω–æ–≤–ª—è–µ—Ç –±–∏–±–ª–∏–æ—Ç–µ–∫—É –∏–≥—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
        –°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ç–æ–ª—å–∫–æ —Ç–µ –∏–≥—Ä—ã, –∫–æ—Ç–æ—Ä—ã–µ —É–∂–µ –µ—Å—Ç—å –≤ –Ω–∞—à–µ–π –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö (—Ç–∞–±–ª–∏—Ü–∞ games).
        """
        # 1. –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–ø–∏—Å–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –¥–ª—è —ç—Ç–æ–≥–æ —é–∑–µ—Ä–∞
        await self.session.execute(
            delete(UserLibrary).where(UserLibrary.user_id == telegram_id)
        )
        
        # 2. –°–æ–±–∏—Ä–∞–µ–º ID –∏–≥—Ä –∏–∑ –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö (–≥–¥–µ –≤—Ä–µ–º—è –∏–≥—Ä—ã > 0)
        steam_app_ids = [g['appid'] for g in games_data if g.get('playtime_forever', 0) > 0]
        
        if not steam_app_ids:
            return

        # 3. –ò—â–µ–º, –∫–∞–∫–∏–µ –∏–∑ —ç—Ç–∏—Ö ID —Ä–µ–∞–ª—å–Ω–æ —Å—É—â–µ—Å—Ç–≤—É—é—Ç –≤ –Ω–∞—à–µ–π —Ç–∞–±–ª–∏—Ü–µ games
        # (–ß—Ç–æ–±—ã –Ω–µ –ø—ã—Ç–∞—Ç—å—Å—è –¥–æ–±–∞–≤–∏—Ç—å —Å–≤—è–∑—å —Å –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –∏–≥—Ä–æ–π)
        result = await self.session.execute(
            select(Game.id).where(Game.id.in_(steam_app_ids))
        )
        existing_ids = set(result.scalars().all()) # –ú–Ω–æ–∂–µ—Å—Ç–≤–æ ID, –∫–æ—Ç–æ—Ä—ã–µ –µ—Å—Ç—å –≤ –±–∞–∑–µ
        
        # 4. –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –æ–±—ä–µ–∫—Ç–æ–≤ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏
        library_items = []
        for g in games_data:
            app_id = g['appid']
            
            if app_id in existing_ids and g.get('playtime_forever', 0) > 0:
                item = UserLibrary(
                    user_id=telegram_id,
                    game_id=app_id,
                    playtime_forever=g.get('playtime_forever', 0),
                    playtime_2weeks=g.get('playtime_2weeks', 0)
                )
                library_items.append(item)
        
        # 5. –ú–∞—Å—Å–æ–≤–∞—è –≤—Å—Ç–∞–≤–∫–∞
        if library_items:
            self.session.add_all(library_items)
            await self.session.commit()import logging
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, text, or_, and_, func, case
from sqlalchemy.orm.attributes import flag_modified # <--- –í–ê–ñ–ù–´–ô –ò–ú–ü–û–†–¢
from database.models import Game, Achievement
from services.text_utils import clean_query, fix_layout

class GameRepo:
    def __init__(self, session: AsyncSession):
        self.session = session

    async def get_by_id(self, game_id: int) -> Game | None:
        result = await self.session.execute(select(Game).where(Game.id == game_id))
        return result.scalars().first()
        
    async def get_random_game(self) -> Game | None:
        stmt = select(Game).where(Game.reviews_total > 500).order_by(func.random()).limit(1)
        result = await self.session.execute(stmt)
        return result.scalars().first()

    async def get_achievements(self, game_id: int) -> list[Achievement]:
        stmt = select(Achievement).where(Achievement.game_id == game_id).order_by(Achievement.global_percent.desc())
        result = await self.session.execute(stmt)
        return result.scalars().all()

    # === –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ú–ï–¢–û–î ===
    async def delete_broken_media(self, game_id: int, broken_url: str):
        """–£–¥–∞–ª—è–µ—Ç URL –∏–∑ —Å–ø–∏—Å–∫–∞ –∏ –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–û —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è"""
        game = await self.get_by_id(game_id)
        if not game: return False

        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ (–∫–æ–ø–∏—Ä—É–µ–º —Å–ª–æ–≤–∞—Ä—å)
        extra = dict(game.extra_data) if game.extra_data else {}
        changed = False

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–∫—Ä–∏–Ω—à–æ—Ç—ã
        if 'screenshots' in extra and broken_url in extra['screenshots']:
            extra['screenshots'].remove(broken_url)
            changed = True
            logging.warning(f"üóë –£–¥–∞–ª–µ–Ω –±–∏—Ç—ã–π —Å–∫—Ä–∏–Ω—à–æ—Ç: {broken_url}")

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∏–¥–µ–æ
        if 'movies' in extra and broken_url in extra['movies']:
            extra['movies'].remove(broken_url)
            changed = True
            logging.warning(f"üóë –£–¥–∞–ª–µ–Ω–æ –±–∏—Ç–æ–µ –≤–∏–¥–µ–æ: {broken_url}")

        if changed:
            # 1. –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–µ
            game.extra_data = extra
            
            # 2. –í–ê–ñ–ù–û: –Ø–≤–Ω–æ –ø–æ–º–µ—á–∞–µ–º –ø–æ–ª–µ –∫–∞–∫ –∏–∑–º–µ–Ω–µ–Ω–Ω–æ–µ –¥–ª—è SQLAlchemy
            flag_modified(game, "extra_data")
            
            # 3. –°–æ—Ö—Ä–∞–Ω—è–µ–º
            await self.session.commit()
            return True
            
        return False

    async def search(self, query: str, limit: int = 10):
        raw_q = query.strip()
        clean_q = clean_query(raw_q)     
        switched_q = fix_layout(raw_q)   
        clean_switched = clean_query(switched_q)
        words = clean_q.split()
        db_clean_name = func.regexp_replace(Game.name, r'[^a-zA-Z0-9–∞-—è–ê-–Ø0-9]', ' ', 'g')

        conditions = []
        conditions.append(text("name % :q"))
        conditions.append(text("name % :switched"))
        conditions.append(db_clean_name.ilike(f"%{clean_q}%"))
        conditions.append(db_clean_name.ilike(f"%{clean_switched}%"))
        
        if len(words) > 1:
            word_conditions = [Game.name.ilike(f"%{w}%") for w in words]
            conditions.append(and_(*word_conditions))

        stmt = select(Game).where(or_(*conditions)).order_by(
            case((func.lower(db_clean_name) == func.lower(clean_q), 0), else_=1),
            case((Game.name.ilike(f"{clean_q}%"), 0), else_=1),
            func.length(Game.name).asc(),
            func.similarity(Game.name, clean_q).desc(),
            Game.reviews_total.desc()
        ).limit(limit)

        try:
            result = await self.session.execute(stmt, {"q": clean_q, "switched": clean_switched})
            return result.scalars().all()
        except Exception as e:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: {e}")
            return []from aiogram import Router, types, F
from sqlalchemy.ext.asyncio import AsyncSession

from database.repo.games import GameRepo
from keyboards.game_card import get_search_results_kb
from handlers.game_details import send_game_interface 

router = Router()

# --- –•–ï–ù–î–õ–ï–†–´ –ú–ï–ù–Æ ---

@router.message(F.text == "üéÆ –ü–æ–∏—Å–∫ –∏–≥—Ä")
async def menu_search_btn(message: types.Message):
    await message.answer("‚úçÔ∏è –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã –≤ —á–∞—Ç, –∏ —è –Ω–∞–π–¥—É –µ—ë.\n\n<i>–ù–∞–ø—Ä–∏–º–µ—Ä: –í–µ–¥—å–º–∞–∫, CS2, Stalker</i>", parse_mode="HTML")

@router.message(F.text == "üé≤ –°–ª—É—á–∞–π–Ω–∞—è –∏–≥—Ä–∞")
async def menu_random_btn(message: types.Message, session: AsyncSession):
    repo = GameRepo(session)
    game = await repo.get_random_game()
    if game:
        # –î–û–ë–ê–í–õ–ï–ù–ê SESSION
        await send_game_interface(message, game, session)
    else:
        await message.answer("–í –±–∞–∑–µ –ø–æ–∫–∞ –ø—É—Å—Ç–æ üòî")

@router.message(F.text == "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏")
async def menu_settings_btn(message: types.Message):
    await message.answer("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–∫–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ üõ†")

# --- –•–ï–ù–î–õ–ï–† –ü–û–ò–°–ö–ê ---

@router.message(F.text)
async def search_games(message: types.Message, session: AsyncSession):
    query = message.text.strip()
    
    if query.startswith("/") or len(query) < 2:
        return

    if query in ["üë§ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å", "üéÆ –ü–æ–∏—Å–∫ –∏–≥—Ä", "üé≤ –°–ª—É—á–∞–π–Ω–∞—è –∏–≥—Ä–∞", "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏"]:
        return

    repo = GameRepo(session)
    games = await repo.search(query)

    if not games:
        await message.answer(f"‚ùå –ü–æ –∑–∞–ø—Ä–æ—Å—É <b>'{query}'</b> –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", parse_mode="HTML")
        return

    if len(games) == 1:
        # –î–û–ë–ê–í–õ–ï–ù–ê SESSION
        await send_game_interface(message, games[0], session)
    else:
        await message.answer(
            f"üîé –ù–∞–π–¥–µ–Ω–æ –∏–≥—Ä: {len(games)}. –í—ã–±–µ—Ä–∏ –Ω—É–∂–Ω—É—é:",
            reply_markup=get_search_results_kb(games)
        )from aiogram import Router, types, F
from aiogram.types import InputMediaPhoto
from aiogram.enums import ContentType, ParseMode
from sqlalchemy.ext.asyncio import AsyncSession

from database.repo.games import GameRepo
from keyboards.achievements import get_achievements_pagination
from services.game_sync import sync_game_achievements # <--- –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –Ω–∞—à –Ω–æ–≤—ã–π —Å–µ—Ä–≤–∏—Å

router = Router()

@router.callback_query(F.data.startswith("ach_"))
async def achievement_navigation(callback: types.CallbackQuery, session: AsyncSession):
    # data: ach_GAMEID_INDEX_IMGID
    parts = callback.data.split("_")
    game_id = int(parts[1])
    index = int(parts[2])
    image_msg_id = int(parts[3]) if len(parts) > 3 else 0
    
    repo = GameRepo(session)
    
    # 1. –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∞—á–∏–≤–∫–∏ –∏–∑ –±–∞–∑—ã
    achievements = await repo.get_achievements(game_id)
    
    # 2. –ï—Å–ª–∏ –≤ –±–∞–∑–µ –ø—É—Å—Ç–æ ‚Äî –ø—Ä–æ–±—É–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑ Steam
    if not achievements:
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ (Toast), —á—Ç–æ–±—ã —é–∑–µ—Ä –Ω–µ —Å–∫—É—á–∞–ª
        await callback.answer("‚è≥ –ê—á–∏–≤–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ó–∞–≥—Ä—É–∂–∞—é –∏–∑ Steam...", show_alert=False)
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é
        success = await sync_game_achievements(session, game_id)
        
        if success:
            # –ï—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ, –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ —Å–Ω–æ–≤–∞
            achievements = await repo.get_achievements(game_id)
        else:
            return await callback.answer("‚ùå –£ —ç—Ç–æ–π –∏–≥—Ä—ã –Ω–µ—Ç –∞—á–∏–≤–æ–∫ –∏–ª–∏ –æ—à–∏–±–∫–∞ Steam.", show_alert=True)

    # –ï—Å–ª–∏ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –≤—Å–µ —Ä–∞–≤–Ω–æ –ø—É—Å—Ç–æ (—Å—Ç—Ä–∞–Ω–Ω–æ, –Ω–æ –±—ã–≤–∞–µ—Ç)
    if not achievements:
        return await callback.answer("–°–ø–∏—Å–æ–∫ –∞—á–∏–≤–æ–∫ –ø—É—Å—Ç.", show_alert=True)

    total = len(achievements)
    if index < 0: index = 0
    if index >= total: index = total - 1
    
    ach = achievements[index]
    
    # --- –§–û–†–ú–ò–†–û–í–ê–ù–ò–ï –¢–ï–ö–°–¢–ê (–∫–∞–∫ —Ä–∞–Ω—å—à–µ) ---
    locales = ach.locales or {}
    ru_data = locales.get('ru') or {}
    en_data = locales.get('en') or {}
    name = ru_data.get('name') or en_data.get('name') or ach.api_name
    
    raw_desc = ru_data.get('desc') or en_data.get('desc')
    if raw_desc: desc = raw_desc
    elif ach.is_hidden: desc = "üîí <i>–≠—Ç–æ —Å–∫—Ä—ã—Ç–æ–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ. –ü–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏ —Ä–∞—Å–∫—Ä—ã–≤–∞—é—Ç—Å—è –ø–æ —Ö–æ–¥—É –∏–≥—Ä—ã.</i>"
    else: desc = "–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç."
    
    percent = ach.global_percent
    rarity_emoji = "üü¢"
    rarity_text = "–û–±—ã—á–Ω–∞—è"
    if percent < 10: 
        rarity_emoji = "üî¥"
        rarity_text = "–õ–µ–≥–µ–Ω–¥–∞—Ä–Ω–∞—è"
    elif percent < 30: 
        rarity_emoji = "üü°"
        rarity_text = "–†–µ–¥–∫–∞—è"
    
    caption = (
        f"üèÜ <b>{name}</b>\n\n"
        f"{desc}\n\n"
        f"üìä {rarity_text}: {rarity_emoji} <b>{percent}%</b> –∏–≥—Ä–æ–∫–æ–≤"
    )
    
    keyboard = get_achievements_pagination(game_id, index, total)
    
    # --- –û–¢–ü–†–ê–í–ö–ê ---
    
    if callback.message.content_type == ContentType.TEXT:
        # –í—Ö–æ–¥ –≤ —Ä–µ–∂–∏–º –∞—á–∏–≤–æ–∫
        await callback.message.delete()
        
        # –£–¥–∞–ª—è–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É –∏–≥—Ä—ã, –µ—Å–ª–∏ –æ–Ω–∞ –≤–∏—Å–∏—Ç –≤—ã—à–µ
        if image_msg_id > 0:
            try:
                await callback.bot.delete_message(chat_id=callback.message.chat.id, message_id=image_msg_id)
            except Exception:
                pass 
        
        await callback.message.answer_photo(
            photo=ach.icon_url,
            caption=caption,
            reply_markup=keyboard,
            parse_mode=ParseMode.HTML
        )
    else:
        # –õ–∏—Å—Ç–∞–Ω–∏–µ
        media = InputMediaPhoto(media=ach.icon_url, caption=caption, parse_mode=ParseMode.HTML)
        try:
            await callback.message.edit_media(media=media, reply_markup=keyboard)
        except Exception:
            await callback.answer()# –§–∞–π–ª: steam_bot/handlers/__init__.py

from aiogram import Router
from . import base, onboarding, search, game_details, achievements # <--- –î–æ–±–∞–≤–∏–ª–∏ achievements

def get_handlers_router() -> Router:
    router = Router()
    
    # –ü–æ—Ä—è–¥–æ–∫ –≤–∞–∂–µ–Ω (—Ö–æ—Ç—è —Ç—É—Ç –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–æ)
    router.include_router(base.router)
    router.include_router(onboarding.router)
    router.include_router(search.router)
    router.include_router(game_details.router)
    router.include_router(achievements.router) # <--- –ü–æ–¥–∫–ª—é—á–∏–ª–∏
    
    return routerfrom aiogram import Router, types, F
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from states.user_states import UserStates
from services.steam import steam_service
from database.repo.users import UserRepo
from keyboards.main_menu import get_onboarding_kb

router = Router()

@router.message(F.text == "üë§ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å")
async def my_profile_handler(message: types.Message, state: FSMContext, session: AsyncSession):
    repo = UserRepo(session)
    user = await repo.get_user(message.from_user.id)
    
    if user and user.steam_id:
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç—Ä–∞–Ω—É, –µ—Å–ª–∏ –æ–Ω–∞ –µ—Å—Ç—å, –∏–Ω–∞—á–µ US
        flag = user.country if user.country else "US"
        
        await message.answer(
            f"üë§ <b>–¢–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å:</b>\n"
            f"üÜî Steam ID: <code>{user.steam_id}</code>\n"
            f"üåç –†–µ–≥–∏–æ–Ω —Ü–µ–Ω: <b>{flag}</b>\n"
            f"üìÖ –î–∞—Ç–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {user.created_at.strftime('%d.%m.%Y')}\n\n"
            "–ß—Ç–æ–±—ã –æ–±–Ω–æ–≤–∏—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫—É –∏–≥—Ä, –æ—Ç–ø—Ä–∞–≤—å /refresh",
            parse_mode="HTML"
        )
    else:
        # –ï—Å–ª–∏ –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω
        await message.answer(
            "üîó <b>–ü—Ä–∏–≤—è–∑–∫–∞ Steam</b>\n\n"
            "–ü—Ä–∏—à–ª–∏ –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ —Ç–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å Steam –∏–ª–∏ —Ç–≤–æ–π Steam ID.\n"
            "<i>–ü—Ä–∏–º–µ—Ä: https://steamcommunity.com/id/gaben/</i>",
            reply_markup=get_onboarding_kb(),
            parse_mode="HTML"
        )
        await state.set_state(UserStates.waiting_for_steam_link)

@router.message(UserStates.waiting_for_steam_link)
async def process_steam_link(message: types.Message, state: FSMContext, session: AsyncSession):
    input_text = message.text.strip()
    
    # 1. –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å ID
    steam_id = await steam_service.resolve_vanity_url(input_text)
    
    if not steam_id:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç–∞–∫–æ–π –ø—Ä–æ—Ñ–∏–ª—å. –ü—Ä–æ–≤–µ—Ä—å —Å—Å—ã–ª–∫—É.")
        return

    # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –∏–≥—Ä (–ü—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—å)
    await message.answer("‚è≥ –ü—Ä–æ–≤–µ—Ä—è—é –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏...")
    games = await steam_service.get_owned_games(steam_id)
    
    if games is None:
        await message.answer(
            "üîí <b>–ü—Ä–æ—Ñ–∏–ª—å —Å–∫—Ä—ã—Ç!</b>\n\n"
            "–Ø –Ω–µ –≤–∏–∂—É —Ç–≤–æ–∏ –∏–≥—Ä—ã. –û—Ç–∫—Ä–æ–π –∏—Ö –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö Steam:\n"
            "<i>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ—Ñ–∏–ª—å -> –ü—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—å -> –î–æ—Å—Ç—É–ø –∫ –∏–≥—Ä–∞–º: –û—Ç–∫—Ä—ã—Ç—ã–π</i>\n\n"
            "–ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –ø—Ä–∏—à–ª–∏ —Å—Å—ã–ª–∫—É –µ—â–µ —Ä–∞–∑.",
            parse_mode="HTML"
        )
        return

    # 3. –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ –æ —é–∑–µ—Ä–µ (–Ω–∏–∫, –∞–≤–∞—Ç–∞—Ä, –°–¢–†–ê–ù–ê)
    player_summary = await steam_service.get_player_summary(steam_id)
    username = player_summary.get('personaname', 'Unknown')
    avatar = player_summary.get('avatarfull')
    
    # –ü–æ–ª—É—á–∞–µ–º –∫–æ–¥ —Å—Ç—Ä–∞–Ω—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, KZ, RU, US). 
    # –ü—Ä–∏–¥–µ—Ç None, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ —É–∫–∞–∑–∞–ª —Å—Ç—Ä–∞–Ω—É –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø—Ä–æ—Ñ–∏–ª—è Steam.
    country = player_summary.get('loccountrycode')

    # 4. –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
    repo = UserRepo(session)
    await repo.create_or_update(
        telegram_id=message.from_user.id,
        steam_id=int(steam_id),
        username=username,
        avatar=avatar,
        country=country # –ü–µ—Ä–µ–¥–∞–µ–º —Å—Ç—Ä–∞–Ω—É
    )
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫—É
    await repo.update_library(message.from_user.id, games)

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞
    display_country = country if country else "US (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)"
    warning_text = ""
    if not country:
        warning_text = "\n‚ö†Ô∏è <i>–Ø –Ω–µ —Å–º–æ–≥ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–≤–æ–π —Ä–µ–≥–∏–æ–Ω (Steam –Ω–µ –æ—Ç–¥–∞–ª —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ). –¶–µ–Ω—ã –±—É–¥—É—Ç –≤ –¥–æ–ª–ª–∞—Ä–∞—Ö. –£–∫–∞–∂–∏ —Å—Ç—Ä–∞–Ω—É –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø—Ä–æ—Ñ–∏–ª—è Steam –∏ –ø—Ä–∏—à–ª–∏ —Å—Å—ã–ª–∫—É —Å–Ω–æ–≤–∞, —á—Ç–æ–±—ã –∏—Å–ø—Ä–∞–≤–∏—Ç—å.</i>"

    await state.clear()
    await message.answer(
        f"‚úÖ <b>–£—Å–ø–µ—à–Ω–æ!</b>\n"
        f"üë§ –ù–∏–∫: {username}\n"
        f"üåç –†–µ–≥–∏–æ–Ω: {display_country}\n"
        f"üéÆ –ò–≥—Ä –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫–µ: {len(games)}\n"
        f"{warning_text}\n\n"
        "–¢–µ–ø–µ—Ä—å —è –∑–Ω–∞—é, –≤–æ —á—Ç–æ —Ç—ã –∏–≥—Ä–∞–µ—à—å!",
        parse_mode="HTML"
    )import logging
import re
import datetime
from aiogram import Router, types, F
from aiogram.types import InputMediaPhoto, InputMediaVideo
from aiogram.enums import ParseMode
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from sqlalchemy.dialects.postgresql import insert

from database.repo.games import GameRepo
from database.repo.users import UserRepo
from database.models.game import GamePrice
from services.steam import steam_service
from keyboards.pagination import get_media_pagination, get_info_pagination

router = Router()

# === –õ–û–ì–ò–ö–ê –¶–ï–ù ===
async def get_actual_price(session: AsyncSession, game_id: int, user_id: int) -> str:
    user_repo = UserRepo(session)
    user = await user_repo.get_user(user_id)
    country = user.country if (user and user.country) else "US"
    
    stmt = select(GamePrice).where(GamePrice.game_id == game_id, GamePrice.country_code == country)
    result = await session.execute(stmt)
    cached = result.scalars().first()
    
    now = datetime.datetime.now(datetime.timezone.utc)
    
    if cached and cached.updated_at:
        last = cached.updated_at.replace(tzinfo=datetime.timezone.utc) if cached.updated_at.tzinfo is None else cached.updated_at
        if (now - last).total_seconds() < 86400:
            return cached.price_fmt

    new_price = await steam_service.get_game_price(game_id, country)
    if new_price:
        stmt = insert(GamePrice).values(game_id=game_id, country_code=country, price_fmt=new_price, updated_at=now)\
            .on_conflict_do_update(index_elements=['game_id', 'country_code'], set_={"price_fmt": new_price, "updated_at": now})
        await session.execute(stmt)
        await session.commit()
        return new_price
    
    return cached.price_fmt if cached else None

# === –û–¢–ü–†–ê–í–ö–ê –ò–ù–¢–ï–†–§–ï–ô–°–ê ===

async def send_game_interface(message: types.Message, game, session: AsyncSession):
    # 1. –î–∞–Ω–Ω—ã–µ
    locales = game.locales or {}
    extra_data = game.extra_data or {}
    ru_data = locales.get('ru') or {}
    en_data = locales.get('en') or {}
    
    header_url = ru_data.get('header_image') or en_data.get('header_image') or extra_data.get('header_image')
    if not header_url: header_url = "https://via.placeholder.com/460x215?text=No+Image"

    screenshots = extra_data.get('screenshots') or []
    movies = extra_data.get('movies') or []
    total_media = len(screenshots) + len(movies)

    media_kb = get_media_pagination(game.id, -1, total_media, "image")
    
    # 2. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –§–û–¢–û (–û–±–ª–æ–∂–∫–∞ –≤—Å–µ–≥–¥–∞ —Å –ø–æ–¥–ø–∏—Å—å—é –Ω–∞–∑–≤–∞–Ω–∏—è –∏–≥—Ä—ã)
    img_msg = None
    try:
        img_msg = await message.answer_photo(
            photo=header_url,
            caption=f"üñº <b>{game.name}</b>", # <--- –ü–û–î–ü–ò–°–¨ –ò–ì–†–´
            reply_markup=media_kb,
            parse_mode=ParseMode.HTML
        )
    except Exception as e:
        logging.error(f"Error sending photo: {e}")
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–æ—Ç–æ.")

    # 3. –¢–µ–∫—Å—Ç
    custom_price = await get_actual_price(session, game.id, message.chat.id)
    info_text = get_page_text(game, 1, custom_price)
    
    image_msg_id = img_msg.message_id if img_msg else 0
    info_kb = get_info_pagination(game.id, 1, 2, image_msg_id) 
    
    await message.answer(
        text=info_text,
        reply_markup=info_kb,
        parse_mode=ParseMode.HTML,
        disable_web_page_preview=True
    )

# === –ì–ï–ù–ï–†–ê–¢–û–† –¢–ï–ö–°–¢–ê ===
def get_page_text(game, page: int, custom_price: str = None) -> str:
    locales = game.locales or {}
    extra_data = game.extra_data or {}
    ru_data = locales.get('ru') or {}
    en_data = locales.get('en') or {}
    
    desc = ru_data.get('short_desc') or en_data.get('short_desc') or "–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç."
    
    if custom_price: price_str = custom_price
    else:
        if game.is_free: price_str = "Free"
        elif game.price_current:
            val = game.price_current
            price_str = f"{int(val)}$" if val.is_integer() else f"{val}$"
        else: price_str = "‚Äî"

    release = game.release_date or "TBA"
    year_match = re.search(r'\d{4}', release)
    if year_match: release = year_match.group(0)

    time_str = f"{int(game.time_main)} —á." if game.time_main else "‚Äî"
    meta = f"{game.metacritic_score}" if game.metacritic_score else "‚Äî"
    
    if page == 1:
        return (
            f"üéÆ <b>{game.name}</b>\n"
            f"‚≠êÔ∏è <b>{meta}</b>      ‚è± <b>{time_str}</b>\n\n"
            f"{desc}\n\n"
            f"üìÖ {release}    üí∞ <b>{price_str}</b>\n"
            f"‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
            f"üèÜ –ê—á–∏–≤–æ–∫: <b>{game.achievements_count}</b>   üë• –û—Ç–∑—ã–≤–æ–≤: <b>{game.reviews_total:,}</b>".replace(',', ' ')
        )
    
    elif page == 2:
        devs = ", ".join(extra_data.get('developers') or ["–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"])
        pubs = ", ".join(extra_data.get('publishers') or ["–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"])
        reqs = extra_data.get('pc_requirements') or {}
        if isinstance(reqs, list): reqs = {}
        min_req = re.sub(r'<[^>]+>', '', str(reqs.get('minimum', '–ù–µ —É–∫–∞–∑–∞–Ω—ã'))).replace("Minimum:", "").strip()
        if len(min_req) > 500: min_req = min_req[:500] + "..."

        return (
            f"üõ† <b>–°–∏—Å—Ç–µ–º–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è:</b>\n"
            f"<code>{min_req}</code>\n\n"
            f"üë®‚Äçüíª <b>–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫:</b> {devs}\n"
            f"üì¢ <b>–ò–∑–¥–∞—Ç–µ–ª—å:</b> {pubs}\n"
            f"üÜî <b>AppID:</b> <code>{game.id}</code>"
        )
    return "Error"

# === –•–ï–ù–î–õ–ï–†–´ ===

@router.callback_query(F.data.startswith("media_"))
async def callback_media(callback: types.CallbackQuery, session: AsyncSession):
    parts = callback.data.split("_")
    game_id = int(parts[1])
    index = int(parts[2])
    
    repo = GameRepo(session)
    game = await repo.get_by_id(game_id)
    if not game: return

    locales = game.locales or {}
    extra_data = game.extra_data or {}
    ru_data = locales.get('ru') or {}
    en_data = locales.get('en') or {}
    screenshots = extra_data.get('screenshots') or []
    movies = extra_data.get('movies') or []
    total = len(screenshots) + len(movies)

    # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –∏–Ω–¥–µ–∫—Å–∞
    if index >= total and total > 0:
        index = total - 1

    media_obj = None
    current_url = ""
    
    # === –ù–ê–°–¢–†–û–ô–ö–ê –ü–û–î–ü–ò–°–ò ===
    if index == -1:
        # –û–±–ª–æ–∂–∫–∞: –ù–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã
        caption = f"üñº <b>{game.name}</b>"
    else:
        # –°–∫—Ä–∏–Ω—à–æ—Ç—ã/–í–∏–¥–µ–æ: –ë–ï–ó –ø–æ–¥–ø–∏—Å–∏
        caption = None 

    # 1. –û–ë–õ–û–ñ–ö–ê
    if index == -1:
        url = ru_data.get('header_image') or en_data.get('header_image') or extra_data.get('header_image')
        if not url: url = "https://via.placeholder.com/460x215?text=No+Image"
        current_url = url
        media_obj = InputMediaPhoto(media=url, caption=caption, parse_mode=ParseMode.HTML)
    
    # 2. –°–ö–†–ò–ù–®–û–¢
    elif 0 <= index < len(screenshots):
        current_url = screenshots[index]
        media_obj = InputMediaPhoto(media=current_url, caption=caption, parse_mode=ParseMode.HTML)
    
    # 3. –í–ò–î–ï–û
    elif index >= len(screenshots):
        vid_index = index - len(screenshots)
        if vid_index < len(movies):
            current_url = movies[vid_index]
            media_obj = InputMediaVideo(media=current_url, caption=caption, parse_mode=ParseMode.HTML)

    if media_obj:
        try:
            kb = get_media_pagination(game_id, index, total, "mixed")
            await callback.message.edit_media(media=media_obj, reply_markup=kb)
        except Exception as e:
            # === –°–ê–ú–û–û–ß–ò–°–¢–ö–ê ===
            logging.error(f"‚ùå –ë–∏—Ç—ã–π —Ñ–∞–π–ª –æ–±–Ω–∞—Ä—É–∂–µ–Ω: {current_url}. –û—à–∏–±–∫–∞: {e}")
            
            deleted = await repo.delete_broken_media(game_id, current_url)
            
            if deleted:
                await callback.answer("‚ö†Ô∏è –§–∞–π–ª –ø–æ–≤—Ä–µ–∂–¥–µ–Ω. –ò—Å–ø—Ä–∞–≤–ª—è—é...", show_alert=False)
                
                new_total = total - 1
                if index >= new_total and index > -1:
                    index = index - 1
                
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º model_copy –¥–ª—è —Ä–µ–∫—É—Ä—Å–∏–∏
                new_callback = callback.model_copy(update={"data": f"media_{game_id}_{index}"})
                await callback_media(new_callback, session)
            else:
                await callback.answer("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏.", show_alert=True)
            
    else:
        if index != -1:
             new_callback = callback.model_copy(update={"data": f"media_{game_id}_-1"})
             await callback_media(new_callback, session)

@router.callback_query(F.data.startswith("info_"))
async def callback_info(callback: types.CallbackQuery, session: AsyncSession):
    parts = callback.data.split("_")
    game_id = int(parts[1])
    page = int(parts[2])
    image_msg_id = int(parts[3]) if len(parts) > 3 else 0
    
    repo = GameRepo(session)
    game = await repo.get_by_id(game_id)
    if not game: return

    custom_price = await get_actual_price(session, game.id, callback.message.chat.id)
    text = get_page_text(game, page, custom_price)
    
    kb = get_info_pagination(game.id, page, 2, image_msg_id)
    
    try:
        await callback.message.edit_text(text, reply_markup=kb, parse_mode=ParseMode.HTML, disable_web_page_preview=True)
    except Exception:
        await callback.answer()

@router.callback_query(F.data.startswith("view_game_"))
async def callback_view_game_entry(callback: types.CallbackQuery, session: AsyncSession):
    game_id = int(callback.data.split("_")[2])
    repo = GameRepo(session)
    game = await repo.get_by_id(game_id)
    
    if game:
        await callback.message.delete()
        await send_game_interface(callback.message, game, session)
    else:
        await callback.answer("–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")# –§–∞–π–ª: steam_bot/handlers/base.py

from aiogram import Router, types, F
from aiogram.filters import CommandStart
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from keyboards.main_menu import get_main_menu
from database.repo.users import UserRepo

router = Router()

@router.message(CommandStart())
async def cmd_start(message: types.Message, state: FSMContext, session: AsyncSession):
    await state.clear() # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ª—é–±—ã–µ —Å—Ç–∞—Ä—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    
    user_repo = UserRepo(session)
    user = await user_repo.get_user(message.from_user.id)
    
    if user and user.steam_id:
        # –ï—Å–ª–∏ —é–∑–µ—Ä —É–∂–µ –µ—Å—Ç—å –≤ –±–∞–∑–µ
        await message.answer(
            f"üëã –° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º, <b>{user.username or message.from_user.first_name}</b>!\n"
            "–¢—ã –º–æ–∂–µ—à—å –∏—Å–∫–∞—Ç—å –∏–≥—Ä—ã –∏–ª–∏ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å.",
            reply_markup=get_main_menu(),
            parse_mode="HTML"
        )
    else:
        # –ï—Å–ª–∏ –Ω–æ–≤–µ–Ω—å–∫–∏–π
        await message.answer(
            "üëã <b>–ü—Ä–∏–≤–µ—Ç! –Ø Steam Explorer.</b>\n\n"
            "–Ø –ø–æ–º–æ–≥—É —Ç–µ–±–µ:\n"
            "üîπ –°–ª–µ–¥–∏—Ç—å –∑–∞ –∞—á–∏–≤–∫–∞–º–∏\n"
            "üîπ –ò—Å–∫–∞—Ç—å –∏–≥—Ä—ã (–¥–∞–∂–µ –µ—Å–ª–∏ —Ç—ã –∑–∞–±—ã–ª –Ω–∞–∑–≤–∞–Ω–∏–µ)\n"
            "üîπ –£–∑–Ω–∞—Ç—å –≤—Ä–µ–º—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è\n\n"
            "–ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å, –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É <b>'üë§ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å'</b> –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã.",
            reply_markup=get_main_menu(),
            parse_mode="HTML"
        )import asyncio
import aiohttp
import json
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from sqlalchemy import select, update
from database.models import Game # –£–±–µ–¥–∏—Å—å, —á—Ç–æ –ø—É—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π
from config import conf

TARGET_ID = 1222140 # Detroit: Become Human

async def fetch_store_data(app_id):
    url = f"https://store.steampowered.com/api/appdetails?appids={app_id}&cc=ru&l=russian"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            if resp.status == 200:
                data = await resp.json()
                if data[str(app_id)]['success']:
                    return data[str(app_id)]['data']
    return None

async def update_game():
    print(f"üöÄ –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è Detroit (ID: {TARGET_ID})...")
    
    data = await fetch_store_data(TARGET_ID)
    if not data:
        print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ Steam.")
        return

    # 1. –°–æ–±–∏—Ä–∞–µ–º –º–µ–¥–∏–∞ (–°–∫—Ä–∏–Ω—à–æ—Ç—ã + –í–∏–¥–µ–æ)
    screenshots = [s['path_full'] for s in data.get('screenshots', [])]
    movies = []
    if 'movies' in data:
        for m in data['movies']:
            # –ë–µ—Ä–µ–º mp4 –≤ 480p (—á—Ç–æ–±—ã —Ç–µ–ª–µ–≥—Ä–∞–º –±—ã—Å—Ç—Ä–æ –≥—Ä—É–∑–∏–ª)
            if 'mp4' in m:
                movies.append(m['mp4'].get('480', m['mp4'].get('max')))
    
    # 2. –°–æ–±–∏—Ä–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ
    locales = {
        "ru": {
            "short_desc": data.get('short_description'),
            "detailed_desc": data.get('detailed_description'), # HTML –æ–ø–∏—Å–∞–Ω–∏–µ
            "header_image": data.get('header_image')
        }
    }

    # 3. –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
    extra_data = {
        "screenshots": screenshots,
        "movies": movies,
        "developers": data.get('developers'),
        "publishers": data.get('publishers'),
        "metacritic": data.get('metacritic', {}).get('score'),
        "pc_requirements": data.get('pc_requirements', {})
    }

    # 4. –ó–∞–ø–∏—Å—å –≤ –ë–î
    engine = create_async_engine(conf.database_url, echo=False)
    async_session = sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)

    async with async_session() as session:
        result = await session.execute(select(Game).where(Game.id == TARGET_ID))
        game = result.scalars().first()

        if not game:
            print("–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –±–∞–∑–µ, —Å–æ–∑–¥–∞—é...")
            game = Game(id=TARGET_ID, name=data['name'])
            session.add(game)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—è
        game.price_current = data.get('price_overview', {}).get('final', 0) / 100
        game.metacritic_score = extra_data['metacritic'] or 0
        game.locales = locales
        game.extra_data = extra_data
        
        await session.commit()
        print("‚úÖ –î–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã! –°–∫—Ä–∏–Ω—à–æ—Ç–æ–≤:", len(screenshots), "–í–∏–¥–µ–æ:", len(movies))

    await engine.dispose()

if __name__ == "__main__":
    asyncio.run(update_game())import asyncio
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy import text
from config import conf

async def fix_db():
    engine = create_async_engine(conf.database_url, echo=True)
    
    print("üîß –ò—Å–ø—Ä–∞–≤–ª—è–µ–º —Ç–∞–±–ª–∏—Ü—É users...")
    
    async with engine.begin() as conn:
        # –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–¥–æ—Å—Ç–∞—é—â—É—é –∫–æ–ª–æ–Ω–∫—É avatar_url
        await conn.execute(text("ALTER TABLE users ADD COLUMN IF NOT EXISTS avatar_url VARCHAR;"))
        
    print("‚úÖ –ö–æ–ª–æ–Ω–∫–∞ avatar_url —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–∞!")
    await engine.dispose()

if __name__ == "__main__":
    asyncio.run(fix_db())