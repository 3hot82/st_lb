from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types import InlineKeyboardMarkup

def get_media_pagination(game_id: int, current_index: int, total_count: int, media_type: str) -> InlineKeyboardMarkup:
    """
    –ö–Ω–æ–ø–∫–∏ –¥–ª—è –ª–∏—Å—Ç–∞–Ω–∏—è –º–µ–¥–∏–∞.
    current_index:
      -1 = –ì–ª–∞–≤–Ω–∞—è –∫–∞—Ä—Ç–∏–Ω–∫–∞ (Header)
       0..N = –°–∫—Ä–∏–Ω—à–æ—Ç—ã
       N+1..M = –í–∏–¥–µ–æ
    """
    builder = InlineKeyboardBuilder()
    
    # –ö–Ω–æ–ø–∫–∞ –ù–∞–∑–∞–¥
    if current_index > -1:
        builder.button(text="‚¨ÖÔ∏è", callback_data=f"media_{game_id}_{current_index - 1}")
    
    # –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∫–Ω–æ–ø–∫–∞ (–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä)
    label = "–ì–ª–∞–≤–Ω–∞—è" if current_index == -1 else f"{current_index + 1}/{total_count}"
    builder.button(text=f"üñº {label}", callback_data="ignore")

    # –ö–Ω–æ–ø–∫–∞ –í–ø–µ—Ä–µ–¥
    if current_index < total_count - 1:
        builder.button(text="‚û°Ô∏è", callback_data=f"media_{game_id}_{current_index + 1}")
    
    builder.adjust(3)
    return builder.as_markup()

def get_info_pagination(game_id: int, current_page: int, total_pages: int) -> InlineKeyboardMarkup:
    """–ö–Ω–æ–ø–∫–∏ –¥–ª—è –ª–∏—Å—Ç–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞"""
    builder = InlineKeyboardBuilder()
    
    # –ù–∞–≤–∏–≥–∞—Ü–∏—è —Å—Ç—Ä–∞–Ω–∏—Ü
    if current_page > 1:
        builder.button(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"info_{game_id}_{current_page - 1}")
    
    builder.button(text=f"üìÑ –°—Ç—Ä. {current_page}/{total_pages}", callback_data="ignore")
    
    if current_page < total_pages:
        builder.button(text="–í–ø–µ—Ä–µ–¥ ‚û°Ô∏è", callback_data=f"info_{game_id}_{current_page + 1}")
    
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è (–≤—Å–µ–≥–¥–∞ –≤–Ω–∏–∑—É)
    builder.row(
        # –ö–Ω–æ–ø–∫–∞ –∞—á–∏–≤–æ–∫ (–≤–µ–¥–µ—Ç –≤ –¥—Ä—É–≥–æ–π —Ö–µ–Ω–¥–ª–µ—Ä)
        # builder.button(text="üèÜ –ê—á–∏–≤–∫–∏", callback_data=f"achievements_{game_id}") # –†–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π, –∫–æ–≥–¥–∞ —Å–¥–µ–ª–∞–µ–º –∞—á–∏–≤–∫–∏
    )
    
    return builder.as_markup()# –§–∞–π–ª: steam_bot/keyboards/main_menu.py

from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder

def get_main_menu() -> ReplyKeyboardMarkup:
    builder = ReplyKeyboardBuilder()
    
    # –û—Å–Ω–æ–≤–Ω—ã–µ –∫–Ω–æ–ø–∫–∏
    builder.row(
        KeyboardButton(text="üë§ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å"),
        KeyboardButton(text="üéÆ –ü–æ–∏—Å–∫ –∏–≥—Ä")
    )
    builder.row(
        KeyboardButton(text="üé≤ –°–ª—É—á–∞–π–Ω–∞—è –∏–≥—Ä–∞"), # –ú–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–æ–∑–∂–µ
        KeyboardButton(text="‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏")
    )
    
    return builder.as_markup(resize_keyboard=True)

def get_onboarding_kb() -> InlineKeyboardMarkup:
    """–ö–Ω–æ–ø–∫–∞ –ø–æ–º–æ—â–∏ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏"""
    builder = InlineKeyboardBuilder()
    builder.button(text="‚ùì –ì–¥–µ –≤–∑—è—Ç—å —Å—Å—ã–ª–∫—É?", callback_data="help_steam_link")
    return builder.as_markup()# –§–∞–π–ª: steam_bot/keyboards/game_card.py

from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types import InlineKeyboardMarkup

def get_game_card_kb(game_id: int, has_achievements: bool, has_ru_locale: bool) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    # 1. –°—Å—ã–ª–∫–∞ –Ω–∞ –º–∞–≥–∞–∑–∏–Ω (–≤—Å–µ–≥–¥–∞ –ø–æ–ª–µ–∑–Ω–∞)
    builder.button(text="üõí Steam Store", url=f"https://store.steampowered.com/app/{game_id}/")
    
    # 2. –ê—á–∏–≤–∫–∏ (–µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å)
    if has_achievements:
        builder.button(text="üèÜ –ê—á–∏–≤–∫–∏", callback_data=f"achievements_{game_id}_page_1")
    
    # 3. –¢—Ä–µ–π–ª–µ—Ä—ã (–µ—Å–ª–∏ –µ—Å—Ç—å –≤ –±–∞–∑–µ, –Ω–æ –∫–Ω–æ–ø–∫—É –æ—Å—Ç–∞–≤–∏–º –≤—Å–µ–≥–¥–∞)
    builder.button(text="üìπ –¢—Ä–µ–π–ª–µ—Ä—ã", callback_data=f"trailers_{game_id}")
    
    # 4. –ï—Å–ª–∏ –Ω–µ—Ç —Ä—É—Å—Å–∫–æ–≥–æ –æ–ø–∏—Å–∞–Ω–∏—è - –∫–Ω–æ–ø–∫–∞ –æ–±–Ω–æ–≤–∏—Ç—å
    if not has_ru_locale:
        builder.button(text="üá∑üá∫ –ó–∞–≥—Ä—É–∑–∏—Ç—å RU", callback_data=f"update_ru_{game_id}")

    # –ö—Ä–∞—Å–∏–≤–∞—è —Å–µ—Ç–∫–∞: 1 –∫–Ω–æ–ø–∫–∞ (–º–∞–≥–∞–∑–∏–Ω), –ø–æ—Ç–æ–º –ø–æ 2 –≤ —Ä—è–¥
    builder.adjust(1, 2)
    return builder.as_markup()

def get_search_results_kb(games: list) -> InlineKeyboardMarkup:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –∫–Ω–æ–ø–æ–∫ —Å –Ω–∞–π–¥–µ–Ω–Ω—ã–º–∏ –∏–≥—Ä–∞–º–∏"""
    builder = InlineKeyboardBuilder()
    for game in games:
        # –í callback_data –∫–ª–∞–¥–µ–º ID –∏–≥—Ä—ã
        builder.button(text=f"üéÆ {game.name}", callback_data=f"view_game_{game.id}")
    
    builder.adjust(1)
    return builder.as_markup()import asyncio
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy import text

# –¢–≤–æ–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
DATABASE_URL = "postgresql+asyncpg://postgres:root@localhost/steam_bot_db"

async def check_game():
    engine = create_async_engine(DATABASE_URL, echo=False)
    
    print("üïµÔ∏è‚Äç‚ôÇÔ∏è –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö...")

    async with engine.begin() as conn:
        # 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ ID 70
        print("\n--- –ü–û–ò–°–ö –ü–û ID 1222140 ---")
        result = await conn.execute(text("SELECT id, name, reviews_total FROM games WHERE id = 1222140"))
        game = result.first()
        
        if game:
            print(f"‚úÖ –ò–ì–†–ê –ù–ê–ô–î–ï–ù–ê –ü–û ID!")
            print(f"üÜî ID: {game.id}")
            print(f"üìõ –ò–º—è –≤ –±–∞–∑–µ: '{game.name}'") # –í–∞–∂–Ω–æ: –∫–∞–≤—ã—á–∫–∏ –ø–æ–∫–∞–∂—É—Ç, –µ—Å—Ç—å –ª–∏ –ø—Ä–æ–±–µ–ª—ã
            print(f"üë• –û—Ç–∑—ã–≤–æ–≤: {game.reviews_total}")
        else:
            print("‚ùå –ò–≥—Ä—ã —Å ID 1222140 –ù–ï–¢ –≤ –±–∞–∑–µ.")

        # 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é (–≤–¥—Ä—É–≥ ID –¥—Ä—É–≥–æ–π –∏–ª–∏ –∏–º—è –∫—Ä–∏–≤–æ–µ)
        print("\n--- –ü–û–ò–°–ö –ü–û –ù–ê–ó–í–ê–ù–ò–Æ '%Half%Life%' ---")
        result = await conn.execute(text("SELECT id, name, reviews_total FROM games WHERE name ILIKE '%Half%Life%' ORDER BY reviews_total DESC LIMIT 10"))
        rows = result.all()
        
        if rows:
            for row in rows:
                print(f"üéÆ {row.name} (ID: {row.id}) - –û—Ç–∑—ã–≤–æ–≤: {row.reviews_total}")
        else:
            print("‚ùå –ù–∏—á–µ–≥–æ –ø–æ—Ö–æ–∂–µ–≥–æ –Ω–∞ Half-Life –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")

    await engine.dispose()

if __name__ == "__main__":
    asyncio.run(check_game())# –§–∞–π–ª: steam_bot/services/steam.py

import aiohttp
from typing import Optional, Dict, List, Any
from config import conf

class SteamService:
    BASE_URL = "http://api.steampowered.com"

    def __init__(self):
        self.api_key = conf.steam_api_key

    async def resolve_vanity_url(self, vanity_url: str) -> Optional[str]:
        """–ü—Ä–µ–≤—Ä–∞—â–∞–µ—Ç –Ω–∏–∫–Ω–µ–π–º (vanity url) –≤ SteamID64"""
        # –û—á–∏—â–∞–µ–º —Å—Å—ã–ª–∫—É, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–∫–∏–Ω—É–ª –ø–æ–ª–Ω—ã–π URL
        clean_url = vanity_url.rstrip('/').split('/')[-1]
        
        # –ï—Å–ª–∏ —ç—Ç–æ —É–∂–µ —Ü–∏—Ñ—Ä—ã –∏ –∏—Ö 17 - —ç—Ç–æ ID
        if clean_url.isdigit() and len(clean_url) == 17:
            return clean_url

        url = f"{self.BASE_URL}/ISteamUser/ResolveVanityURL/v0001/"
        params = {"key": self.api_key, "vanityurl": clean_url}

        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params) as resp:
                if resp.status != 200: return None
                data = await resp.json()
                if data.get('response', {}).get('success') == 1:
                    return data['response']['steamid']
        return None

    async def get_player_summary(self, steam_id: str) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∞–µ—Ç –∞–≤–∞—Ç–∞—Ä–∫—É –∏ –Ω–∏–∫–Ω–µ–π–º"""
        url = f"{self.BASE_URL}/ISteamUser/GetPlayerSummaries/v0002/"
        params = {"key": self.api_key, "steamids": steam_id}
        
        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params) as resp:
                data = await resp.json()
                players = data.get('response', {}).get('players', [])
                return players[0] if players else {}

    async def get_owned_games(self, steam_id: str) -> Optional[List[Dict]]:
        """
        –ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∏–≥—Ä.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç None, –µ—Å–ª–∏ –ø—Ä–æ—Ñ–∏–ª—å —Å–∫—Ä—ã—Ç.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ [], –µ—Å–ª–∏ –∏–≥—Ä –Ω–µ—Ç.
        """
        url = f"{self.BASE_URL}/IPlayerService/GetOwnedGames/v0001/"
        params = {
            "key": self.api_key,
            "steamid": steam_id,
            "include_appinfo": 1, # –ù–∞–∑–≤–∞–Ω–∏—è –∏–≥—Ä
            "include_played_free_games": 1
        }

        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params) as resp:
                if resp.status == 500: return None # –ß–∞—Å—Ç–æ –±—ã–≤–∞–µ—Ç –ø—Ä–∏ —Å–∫—Ä—ã—Ç–æ–º –ø—Ä–æ—Ñ–∏–ª–µ
                data = await resp.json()
        
        response = data.get('response', {})
        # –ï—Å–ª–∏ –∫–ª—é—á–∞ 'games' –Ω–µ—Ç, –∑–Ω–∞—á–∏—Ç –ø—Ä–æ—Ñ–∏–ª—å —Å–∫—Ä—ã—Ç –∏–ª–∏ –∏–≥—Ä –Ω–µ—Ç
        return response.get('games')

# –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä, —á—Ç–æ–±—ã –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –µ–≥–æ
steam_service = SteamService()import re

# –°–ª–æ–≤–∞—Ä—å —Ä–∞—Å–∫–ª–∞–¥–∫–∏
LAYOUT_MAPPING = {
    'q': '–π', 'w': '—Ü', 'e': '—É', 'r': '–∫', 't': '–µ', 'y': '–Ω', 'u': '–≥', 'i': '—à', 'o': '—â', 'p': '–∑', '[': '—Ö', ']': '—ä',
    'a': '—Ñ', 's': '—ã', 'd': '–≤', 'f': '–∞', 'g': '–ø', 'h': '—Ä', 'j': '–æ', 'k': '–ª', 'l': '–¥', ';': '–∂', "'": '—ç',
    'z': '—è', 'x': '—á', 'c': '—Å', 'v': '–º', 'b': '–∏', 'n': '—Ç', 'm': '—å', ',': '–±', '.': '—é',
    '–π': 'q', '—Ü': 'w', '—É': 'e', '–∫': 'r', '–µ': 't', '–Ω': 'y', '–≥': 'u', '—à': 'i', '—â': 'o', '–∑': 'p', '—Ö': '[', '—ä': ']',
    '—Ñ': 'a', '—ã': 's', '–≤': 'd', '–∞': 'f', '–ø': 'g', '—Ä': 'h', '–æ': 'j', '–ª': 'k', '–¥': 'l', '–∂': ';', '—ç': "'",
    '—è': 'z', '—á': 'x', '—Å': 'c', '–º': 'v', '–∏': 'b', '—Ç': 'n', '—å': 'm', '–±': ',', '—é': '.'
}

# –°–ª–µ–Ω–≥
ALIASES = {
    "—Ö–∞–ª—Ñ–∞": "Half-Life", "—Ö–ª": "Half-Life", "hl": "Half-Life", "hl2": "Half-Life 2",
    "–¥–æ—Ç–∞": "Dota 2", "–∫—Å": "Counter-Strike", "–∫—Å–≥–æ": "Counter-Strike 2",
    "cs": "Counter-Strike 2", "cs2": "Counter-Strike 2",
    "–≤–µ–¥—å–º–∞–∫": "The Witcher 3", "–≥—Ç–∞": "Grand Theft Auto V",
    "–ø–∞–±–≥": "PUBG", "pubg": "PUBG", "—Ç—É–Ω–¥—Ä–∞": "War Thunder",
    "—Å–∫–∞–π—Ä–∏–º": "Skyrim", "—Å–º—É—Ç–∞": "Smuta", "–≤–∞—Ä—Ñ—Ä–µ–π–º": "Warframe"
}

def fix_layout(text: str) -> str:
    return "".join(LAYOUT_MAPPING.get(char, char) for char in text.lower())

def normalize_roman_numerals(text: str) -> str:
    """–ú–µ–Ω—è–µ—Ç 'gta 5' –Ω–∞ 'gta v', 'civ 6' –Ω–∞ 'civ vi' –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –ø–æ–∏—Å–∫–∞"""
    # –ü—Ä–æ—Å—Ç–∞—è –∑–∞–º–µ–Ω–∞ –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö —Ü–∏—Ñ—Ä
    replacements = {
        r'\b1\b': 'I', r'\b2\b': 'II', r'\b3\b': 'III', r'\b4\b': 'IV', 
        r'\b5\b': 'V', r'\b6\b': 'VI', r'\b7\b': 'VII'
    }
    # –ú—ã –Ω–µ –º–µ–Ω—è–µ–º —Å–∞–º —Ç–µ–∫—Å—Ç –∑–∞–ø—Ä–æ—Å–∞ –∂–µ—Å—Ç–∫–æ, —ç—Ç–æ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
    # –í –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ –ª—É—á—à–µ –æ—Å—Ç–∞–≤–∏—Ç—å –∫–∞–∫ –µ—Å—Ç—å, —Ç–∞–∫ –∫–∞–∫ pg_trgm —Å–ø—Ä–∞–≤–∏—Ç—Å—è —Å–∞–º,
    # –Ω–æ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –ø–æ–∏—Å–∫–∞.
    return text

def clean_query(text: str) -> str:
    """
    –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞:
    1. –ù–∏–∂–Ω–∏–π —Ä–µ–≥–∏—Å—Ç—Ä.
    2. –ó–∞–º–µ–Ω–∞ —Å–ª–µ–Ω–≥–∞.
    3. –£–¥–∞–ª–µ–Ω–∏–µ –í–°–ï–• —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª–æ–≤ (–æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã –∏ —Ü–∏—Ñ—Ä—ã –∏ –ø—Ä–æ–±–µ–ª—ã).
    –≠—Ç–æ –ø–æ–∑–≤–æ–ª–∏—Ç –Ω–∞–π—Ç–∏ 'Half-Life' –ø–æ –∑–∞–ø—Ä–æ—Å—É 'half life'.
    """
    text = text.lower().strip()
    
    # 1. –°–ª–µ–Ω–≥
    if text in ALIASES:
        return ALIASES[text].lower()
    
    # 2. –£–¥–∞–ª—è–µ–º –º—É—Å–æ—Ä (‚Ñ¢, ¬Æ, :)
    text = text.replace("‚Ñ¢", "").replace("¬Æ", "").replace("¬©", "")
    
    # 3. –ó–∞–º–µ–Ω—è–µ–º –ª—é–±—ã–µ –∑–Ω–∞–∫–∏ –ø—Ä–µ–ø–∏–Ω–∞–Ω–∏—è –Ω–∞ –ø—Ä–æ–±–µ–ª—ã (half-life -> half life)
    # –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã, —Ü–∏—Ñ—Ä—ã –∏ –ø—Ä–æ–±–µ–ª—ã
    text = re.sub(r'[^a-z–∞-—è0-9\s]', ' ', text)
    
    # 4. –£–±–∏—Ä–∞–µ–º –¥–≤–æ–π–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã
    text = re.sub(r'\s+', ' ', text).strip()
    
    return textimport asyncio
from sqlalchemy.ext.asyncio import create_async_engine
from database.models.base import Base
from database.models.user import User, UserLibrary
from config import conf

async def init_db():
    print("üöÄ –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π...")
    engine = create_async_engine(conf.database_url, echo=True)
    
    async with engine.begin() as conn:
        # –°–æ–∑–¥–∞—Å—Ç —Ç–∞–±–ª–∏—Ü—ã users –∏ user_library, –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç
        await conn.run_sync(Base.metadata.create_all)
        
    print("‚úÖ –¢–∞–±–ª–∏—Ü—ã —Å–æ–∑–¥–∞–Ω—ã!")
    await engine.dispose()

if __name__ == "__main__":
    asyncio.run(init_db())import os
from dotenv import load_dotenv
from dataclasses import dataclass

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ .env
load_dotenv()

@dataclass
class Config:
    bot_token: str
    steam_api_key: str
    database_url: str

def load_config() -> Config:
    return Config(
        bot_token=os.getenv("BOT_TOKEN"),
        steam_api_key=os.getenv("STEAM_API_KEY"),
        database_url=os.getenv("DATABASE_URL")
    )

# –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–æ–Ω—Ñ–∏–≥–∞, —á—Ç–æ–±—ã –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –µ–≥–æ –≤–µ–∑–¥–µ
conf = load_config()import asyncio
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy import text

DATABASE_URL = "postgresql+asyncpg://postgres:root@localhost/steam_bot_db"

async def fix_db():
    engine = create_async_engine(DATABASE_URL, echo=True)
    print("üîÑ –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ç–∞–±–ª–∏—Ü—ã games...")
    
    async with engine.begin() as conn:
        # –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ –∫–æ–ª–æ–Ω–∫–∏, –∫–æ—Ç–æ—Ä—ã—Ö –º–æ–∂–µ—Ç –Ω–µ —Ö–≤–∞—Ç–∞—Ç—å
        await conn.execute(text("ALTER TABLE games ADD COLUMN IF NOT EXISTS time_plus FLOAT DEFAULT 0;"))
        await conn.execute(text("ALTER TABLE games ADD COLUMN IF NOT EXISTS time_main FLOAT DEFAULT 0;"))
        await conn.execute(text("ALTER TABLE games ADD COLUMN IF NOT EXISTS time_100 FLOAT DEFAULT 0;"))
        await conn.execute(text("ALTER TABLE games ADD COLUMN IF NOT EXISTS hltb_id VARCHAR;"))
        
    print("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∞!")
    await engine.dispose()

if __name__ == "__main__":
    asyncio.run(fix_db())# –§–∞–π–ª: steam_bot/states/user_states.py

from aiogram.fsm.state import State, StatesGroup

class UserStates(StatesGroup):
    # –°–æ—Å—Ç–æ—è–Ω–∏–µ, –∫–æ–≥–¥–∞ –±–æ—Ç –∂–¥–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ Steam
    waiting_for_steam_link = State()
    
    # –°–æ—Å—Ç–æ—è–Ω–∏–µ, –∫–æ–≥–¥–∞ –±–æ—Ç –∂–¥–µ—Ç –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å (–µ—Å–ª–∏ –º—ã —Å–¥–µ–ª–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω—É—é –∫–Ω–æ–ø–∫—É "–ü–æ–∏—Å–∫")
    waiting_for_search = State()# –§–∞–π–ª: steam_bot/middlewares/db_session.py

from typing import Callable, Awaitable, Dict, Any
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject
from sqlalchemy.ext.asyncio import async_sessionmaker

class DbSessionMiddleware(BaseMiddleware):
    def __init__(self, session_pool: async_sessionmaker):
        super().__init__()
        self.session_pool = session_pool

    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any],
    ) -> Any:
        # –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å–µ—Å—Å–∏—é –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∞–ø–¥–µ–π—Ç–∞ (—Å–æ–æ–±—â–µ–Ω–∏—è/–∫–Ω–æ–ø–∫–∏)
        async with self.session_pool() as session:
            # –ö–ª–∞–¥–µ–º —Å–µ—Å—Å–∏—é –≤ data, —á—Ç–æ–±—ã —Ö–µ–Ω–¥–ª–µ—Ä –º–æ–≥ –µ—ë –∑–∞–±—Ä–∞—Ç—å
            data["session"] = session
            # –ü–µ—Ä–µ–¥–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ö–µ–Ω–¥–ª–µ—Ä—É
            return await handler(event, data)# –§–∞–π–ª: steam_bot/main.py

import asyncio
import logging
import sys

from aiogram import Bot, Dispatcher
from config import conf
from database.core import session_maker
from middlewares.db_session import DbSessionMiddleware
from handlers import get_handlers_router

async def main():
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–æ–≤
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
        stream=sys.stdout
    )
    logger = logging.getLogger(__name__)

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    bot = Bot(token=conf.bot_token)
    dp = Dispatcher()

    # –ü–æ–¥–∫–ª—é—á–∞–µ–º Middleware (–ë–î)
    # –¢–µ–ø–µ—Ä—å –≤ –∫–∞–∂–¥—ã–π —Ö–µ–Ω–¥–ª–µ—Ä –±—É–¥–µ—Ç –ø—Ä–∏–ª–µ—Ç–∞—Ç—å –∞—Ä–≥—É–º–µ–Ω—Ç session
    dp.update.middleware(DbSessionMiddleware(session_pool=session_maker))

    # –ü–æ–¥–∫–ª—é—á–∞–µ–º –•–µ–Ω–¥–ª–µ—Ä—ã
    dp.include_router(get_handlers_router())

    logger.info("üöÄ –ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")
    
    # –£–¥–∞–ª—è–µ–º –≤–µ–±—Ö—É–∫–∏ (—á—Ç–æ–±—ã –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Å—Ç–∞—Ä—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è)
    await bot.delete_webhook(drop_pending_updates=True)
    
    # –ó–∞–ø—É—Å–∫
    try:
        await dp.start_polling(bot)
    finally:
        await bot.session.close()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("üõë –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤—Ä—É—á–Ω—É—é.")# –§–∞–π–ª: steam_bot/database/models/game.py

from sqlalchemy import Column, BigInteger, String, Integer, Float, Boolean, JSON, Text, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from .base import Base

class Game(Base):
    __tablename__ = "games"

    id = Column(BigInteger, primary_key=True)  # Steam AppID
    name = Column(String, index=True)
    
    # –≠–∫–æ–Ω–æ–º–∏–∫–∞
    price_current = Column(Float, default=0.0)
    is_free = Column(Boolean, default=False)
    currency = Column(String, default="USD")

    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    reviews_total = Column(Integer, default=0)
    achievements_count = Column(Integer, default=0)
    release_date = Column(String, nullable=True)
    metacritic_score = Column(Integer, default=0)

    # HowLongToBeat
    time_main = Column(Float, default=0)
    time_plus = Column(Float, default=0)
    time_100 = Column(Float, default=0)
    hltb_id = Column(String, nullable=True)

    # JSON –¥–∞–Ω–Ω—ã–µ (–õ–æ–∫–∞–ª–∏–∑–∞—Ü–∏—è –∏ –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ)
    locales = Column(JSON, default={})
    extra_data = Column(JSON, default={})

    updated_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # –°–≤—è–∑–∏
    achievements = relationship("Achievement", back_populates="game", cascade="all, delete-orphan")
    price_alerts = relationship("PriceAlert", back_populates="game", cascade="all, delete-orphan")

class Achievement(Base):
    __tablename__ = "achievements"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    game_id = Column(BigInteger, ForeignKey("games.id"), index=True)
    
    api_name = Column(String)
    category = Column(String, default="base") # base / dlc_name
    locales = Column(JSON, default={})        # {"ru": {...}, "en": {...}}
    icon_url = Column(String)
    
    is_hidden = Column(Boolean, default=False)
    global_percent = Column(Float, default=0.0)

    game = relationship("Game", back_populates="achievements")

class PriceAlert(Base):
    __tablename__ = "price_alerts"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(BigInteger, index=True) # Telegram ID
    game_id = Column(BigInteger, ForeignKey("games.id"))
    target_price = Column(Integer) # –¶–µ–Ω–∞, –∫–æ—Ç–æ—Ä—É—é –∂–¥–µ—Ç —é–∑–µ—Ä
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    game = relationship("Game", back_populates="price_alerts")# –§–∞–π–ª: steam_bot/database/models/user.py

from sqlalchemy import Column, BigInteger, String, Integer, Boolean, JSON, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from .base import Base

class User(Base):
    __tablename__ = "users"

    telegram_id = Column(BigInteger, primary_key=True)
    steam_id = Column(BigInteger, unique=True, nullable=True)
    
    username = Column(String, nullable=True)
    language = Column(String, default="ru")
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # –°–≤—è–∑—å —Å –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π
    library = relationship("UserLibrary", back_populates="user", cascade="all, delete-orphan")

class UserLibrary(Base):
    __tablename__ = "user_library"

    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(BigInteger, ForeignKey("users.telegram_id"), index=True)
    game_id = Column(BigInteger, ForeignKey("games.id"), index=True)
    
    playtime_forever = Column(Integer, default=0) # –ú–∏–Ω—É—Ç—ã
    playtime_2weeks = Column(Integer, default=0)
    
    user = relationship("User", back_populates="library")
    # game = relationship("Game") # –ú–æ–∂–Ω–æ —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å, –µ—Å–ª–∏ –Ω—É–∂–µ–Ω –ø—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ –∏–≥—Ä–µ# –§–∞–π–ª: steam_bot/database/models/__init__.py

from .base import Base
from .game import Game, Achievement, PriceAlert
from .user import User, UserLibrary

__all__ = [
    "Base",
    "Game",
    "Achievement",
    "PriceAlert",
    "User",
    "UserLibrary"
]# –§–∞–π–ª: steam_bot/database/models/base.py

from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    """
    –ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –≤—Å–µ—Ö –º–æ–¥–µ–ª–µ–π SQLAlchemy.
    –ü–æ–∑–≤–æ–ª—è–µ—Ç –Ω–µ –ø–∏—Å–∞—Ç—å __tablename__ –∫–∞–∂–¥—ã–π —Ä–∞–∑ –≤—Ä—É—á–Ω—É—é (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ),
    –Ω–æ –º—ã –±—É–¥–µ–º –ø–∏—Å–∞—Ç—å —è–≤–Ω–æ –¥–ª—è –ø–æ—Ä—è–¥–∫–∞.
    """
    passfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from config import conf

# –°–æ–∑–¥–∞–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –¥–≤–∏–∂–æ–∫
# echo=False, —á—Ç–æ–±—ã –Ω–µ –∑–∞—Å–æ—Ä—è—Ç—å –∫–æ–Ω—Å–æ–ª—å SQL-–∑–∞–ø—Ä–æ—Å–∞–º–∏ (–ø–æ—Å—Ç–∞–≤—å True –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
engine = create_async_engine(conf.database_url, echo=False)

# –§–∞–±—Ä–∏–∫–∞ —Å–µ—Å—Å–∏–π. –ß–µ—Ä–µ–∑ –Ω–µ—ë –º—ã –±—É–¥–µ–º –ø–æ–ª—É—á–∞—Ç—å –¥–æ—Å—Ç—É–ø –∫ –ë–î –≤ —Ö–µ–Ω–¥–ª–µ—Ä–∞—Ö.
# expire_on_commit=False –≤–∞–∂–µ–Ω –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã.
session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def get_session() -> AsyncSession:
    """
    –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å–µ—Å—Å–∏–π –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è—Ö (–µ—Å–ª–∏ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è)
    –∏–ª–∏ –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞.
    """
    async with session_maker() as session:
        yield sessionfrom sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, delete
from database.models import User, UserLibrary, Game # –î–æ–±–∞–≤–∏–ª–∏ Game

class UserRepo:
    def __init__(self, session: AsyncSession):
        self.session = session

    async def get_user(self, telegram_id: int) -> User | None:
        result = await self.session.execute(select(User).where(User.telegram_id == telegram_id))
        return result.scalars().first()

    async def create_or_update(self, telegram_id: int, steam_id: int, username: str = None, avatar: str = None):
        user = await self.get_user(telegram_id)
        
        if not user:
            user = User(telegram_id=telegram_id, steam_id=steam_id)
            self.session.add(user)
        else:
            user.steam_id = steam_id
        
        if username: user.username = username
        if avatar: user.avatar_url = avatar
        
        await self.session.commit()
        return user

    async def update_library(self, telegram_id: int, games_data: list):
        """
        –û–±–Ω–æ–≤–ª—è–µ—Ç –±–∏–±–ª–∏–æ—Ç–µ–∫—É. –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –¢–û–õ–¨–ö–û —Ç–µ –∏–≥—Ä—ã, –∫–æ—Ç–æ—Ä—ã–µ –µ—Å—Ç—å –≤ –Ω–∞—à–µ–π –±–∞–∑–µ.
        """
        # 1. –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ
        await self.session.execute(
            delete(UserLibrary).where(UserLibrary.user_id == telegram_id)
        )
        
        # 2. –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ ID –≤—Å–µ—Ö –∏–≥—Ä, –∫–æ—Ç–æ—Ä—ã–µ –µ—Å—Ç—å —É –Ω–∞—Å –≤ –±–∞–∑–µ
        # (–ß—Ç–æ–±—ã –Ω–µ –¥–µ–ª–∞—Ç—å 1000 –∑–∞–ø—Ä–æ—Å–æ–≤, –≤—ã–≥—Ä—É–∑–∏–º –≤—Å–µ ID –∏–∑ games_data –∏ –ø—Ä–æ–≤–µ—Ä–∏–º –∏—Ö —Ä–∞–∑–æ–º)
        
        # –°–æ–±–∏—Ä–∞–µ–º ID –∏–≥—Ä –∏–∑ —Å—Ç–∏–º–∞
        steam_app_ids = [g['appid'] for g in games_data if g.get('playtime_forever', 0) > 0]
        
        if not steam_app_ids:
            return

        # –ò—â–µ–º, –∫–∞–∫–∏–µ –∏–∑ —ç—Ç–∏—Ö ID –µ—Å—Ç—å –≤ –Ω–∞—à–µ–π –±–∞–∑–µ
        # SELECT id FROM games WHERE id IN (...)
        result = await self.session.execute(
            select(Game.id).where(Game.id.in_(steam_app_ids))
        )
        existing_ids = set(result.scalars().all()) # –ú–Ω–æ–∂–µ—Å—Ç–≤–æ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö ID
        
        # 3. –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏
        library_items = []
        for g in games_data:
            app_id = g['appid']
            
            # –ï—Å–ª–∏ –∏–≥—Ä–∞ –µ—Å—Ç—å –≤ –Ω–∞—à–µ–π –±–∞–∑–µ –ò –≤ –Ω–µ—ë –∏–≥—Ä–∞–ª–∏
            if app_id in existing_ids and g.get('playtime_forever', 0) > 0:
                item = UserLibrary(
                    user_id=telegram_id,
                    game_id=app_id,
                    playtime_forever=g.get('playtime_forever', 0),
                    playtime_2weeks=g.get('playtime_2weeks', 0)
                )
                library_items.append(item)
        
        # 4. –°–æ—Ö—Ä–∞–Ω—è–µ–º
        if library_items:
            self.session.add_all(library_items)
            await self.session.commit()import logging
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, text, or_, and_, func, case
from database.models import Game
from services.text_utils import clean_query, fix_layout

class GameRepo:
    def __init__(self, session: AsyncSession):
        self.session = session

    async def get_by_id(self, game_id: int) -> Game | None:
        result = await self.session.execute(select(Game).where(Game.id == game_id))
        return result.scalars().first()
        
    async def get_random_game(self) -> Game | None:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–¥–Ω—É —Å–ª—É—á–∞–π–Ω—É—é –∏–≥—Ä—É (—Å —Ä–µ–π—Ç–∏–Ω–≥–æ–º –∏ –æ—Ç–∑—ã–≤–∞–º–∏)"""
        stmt = select(Game).where(
            Game.reviews_total > 500  # –ù–µ —Å–æ–≤—Å–µ–º –º—É—Å–æ—Ä
        ).order_by(func.random()).limit(1)
        
        result = await self.session.execute(stmt)
        return result.scalars().first()

    async def search(self, query: str, limit: int = 10):
        raw_q = query.strip()
        clean_q = clean_query(raw_q)     
        switched_q = fix_layout(raw_q)   
        clean_switched = clean_query(switched_q)
        
        words = clean_q.split()
        
        logging.info(f"üîç SEARCH: '{raw_q}' -> Clean: '{clean_q}'")

        # –û—á–∏—â–∞–µ–º –∏–º—è –≤ –ë–î –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è (—É–±–∏—Ä–∞–µ–º —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª—ã)
        db_clean_name = func.regexp_replace(Game.name, r'[^a-zA-Z0-9–∞-—è–ê-–Ø0-9]', ' ', 'g')

        conditions = []
        # 1. –ù–µ—á–µ—Ç–∫–∏–π –ø–æ–∏—Å–∫
        conditions.append(text("name % :q"))
        conditions.append(text("name % :switched"))
        # 2. –í—Ö–æ–∂–¥–µ–Ω–∏–µ
        conditions.append(db_clean_name.ilike(f"%{clean_q}%"))
        conditions.append(db_clean_name.ilike(f"%{clean_switched}%"))
        # 3. –ü–æ—Å–ª–æ–≤–Ω—ã–π –ø–æ–∏—Å–∫
        if len(words) > 1:
            word_conditions = [Game.name.ilike(f"%{w}%") for w in words]
            conditions.append(and_(*word_conditions))

        stmt = select(Game).where(
            or_(*conditions)
        ).order_by(
            # --- –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê –°–û–†–¢–ò–†–û–í–ö–ò ---
            
            # 1. –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –ï—Å–ª–∏ –æ—á–∏—â–µ–Ω–Ω–æ–µ –∏–º—è –≤ –ë–î –†–ê–í–ù–û –∑–∞–ø—Ä–æ—Å—É (Half-Life == half life)
            case(
                (func.lower(db_clean_name) == func.lower(clean_q), 0),
                else_=1
            ),
            
            # 2. –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –ï—Å–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –ù–ê–ß–ò–ù–ê–ï–¢–°–Ø —Å –∑–∞–ø—Ä–æ—Å–∞
            case(
                (Game.name.ilike(f"{clean_q}%"), 0),
                else_=1
            ),
            
            # 3. –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –î–ª–∏–Ω–∞ –Ω–∞–∑–≤–∞–Ω–∏—è (–ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é).
            # "Half-Life" (9 —Å–∏–º–≤) –±—É–¥–µ—Ç –≤—ã—à–µ "Half-Life 2" (11 —Å–∏–º–≤)
            func.length(Game.name).asc(),
            
            # 4. –°—Ö–æ–∂–µ—Å—Ç—å —Ç–µ–∫—Å—Ç–∞
            func.similarity(Game.name, clean_q).desc(),
            
            # 5. –ü–æ–ø—É–ª—è—Ä–Ω–æ—Å—Ç—å (–∫–∞–∫ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ñ–∞–∫—Ç–æ—Ä)
            Game.reviews_total.desc()
        ).limit(limit)

        try:
            result = await self.session.execute(stmt, {"q": clean_q, "switched": clean_switched})
            games = result.scalars().all()
            return games
        except Exception as e:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: {e}")
            return []from aiogram import Router, types, F
from sqlalchemy.ext.asyncio import AsyncSession

from database.repo.games import GameRepo
from keyboards.game_card import get_search_results_kb
# –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é send_game_interface
from handlers.game_details import send_game_interface 

router = Router()

# --- –•–ï–ù–î–õ–ï–†–´ –ú–ï–ù–Æ ---

@router.message(F.text == "üéÆ –ü–æ–∏—Å–∫ –∏–≥—Ä")
async def menu_search_btn(message: types.Message):
    await message.answer("‚úçÔ∏è –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã –≤ —á–∞—Ç, –∏ —è –Ω–∞–π–¥—É –µ—ë.\n\n<i>–ù–∞–ø—Ä–∏–º–µ—Ä: –í–µ–¥—å–º–∞–∫, CS2, Stalker</i>", parse_mode="HTML")

@router.message(F.text == "üé≤ –°–ª—É—á–∞–π–Ω–∞—è –∏–≥—Ä–∞")
async def menu_random_btn(message: types.Message, session: AsyncSession):
    repo = GameRepo(session)
    game = await repo.get_random_game()
    if game:
        # –ò–ó–ú–ï–ù–ï–ù–ò–ï: –í—ã–∑—ã–≤–∞–µ–º –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        await send_game_interface(message, game)
    else:
        await message.answer("–í –±–∞–∑–µ –ø–æ–∫–∞ –ø—É—Å—Ç–æ üòî")

@router.message(F.text == "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏")
async def menu_settings_btn(message: types.Message):
    await message.answer("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–∫–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ üõ†")

# --- –•–ï–ù–î–õ–ï–† –ü–û–ò–°–ö–ê ---

@router.message(F.text)
async def search_games(message: types.Message, session: AsyncSession):
    query = message.text.strip()
    
    if query.startswith("/") or len(query) < 2:
        return

    if query in ["üë§ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å", "üéÆ –ü–æ–∏—Å–∫ –∏–≥—Ä", "üé≤ –°–ª—É—á–∞–π–Ω–∞—è –∏–≥—Ä–∞", "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏"]:
        return

    repo = GameRepo(session)
    games = await repo.search(query)

    if not games:
        await message.answer(f"‚ùå –ü–æ –∑–∞–ø—Ä–æ—Å—É <b>'{query}'</b> –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", parse_mode="HTML")
        return

    if len(games) == 1:
        # –ò–ó–ú–ï–ù–ï–ù–ò–ï: –í—ã–∑—ã–≤–∞–µ–º –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        await send_game_interface(message, games[0])
    else:
        await message.answer(
            f"üîé –ù–∞–π–¥–µ–Ω–æ –∏–≥—Ä: {len(games)}. –í—ã–±–µ—Ä–∏ –Ω—É–∂–Ω—É—é:",
            reply_markup=get_search_results_kb(games)
        )# –§–∞–π–ª: steam_bot/handlers/__init__.py

from aiogram import Router
from . import base, onboarding, search, game_details

def get_handlers_router() -> Router:
    router = Router()
    
    # –ü–æ–¥–∫–ª—é—á–∞–µ–º —Ä–æ—É—Ç–µ—Ä—ã –∏–∑ —Ñ–∞–π–ª–æ–≤
    router.include_router(base.router)
    router.include_router(onboarding.router)
    router.include_router(search.router)
    router.include_router(game_details.router)
    
    return router# –§–∞–π–ª: steam_bot/handlers/onboarding.py

from aiogram import Router, types, F
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from states.user_states import UserStates
from services.steam import steam_service
from database.repo.users import UserRepo
from keyboards.main_menu import get_onboarding_kb

router = Router()

@router.message(F.text == "üë§ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å")
async def my_profile_handler(message: types.Message, state: FSMContext, session: AsyncSession):
    repo = UserRepo(session)
    user = await repo.get_user(message.from_user.id)
    
    if user and user.steam_id:
        # –ï—Å–ª–∏ —É–∂–µ –ø–æ–¥–∫–ª—é—á–µ–Ω
        await message.answer(
            f"üë§ <b>–¢–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å:</b>\n"
            f"üÜî Steam ID: <code>{user.steam_id}</code>\n"
            f"üìÖ –î–∞—Ç–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {user.created_at.strftime('%d.%m.%Y')}\n\n"
            "–ß—Ç–æ–±—ã –æ–±–Ω–æ–≤–∏—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫—É –∏–≥—Ä, –æ—Ç–ø—Ä–∞–≤—å /refresh",
            parse_mode="HTML"
        )
    else:
        # –ï—Å–ª–∏ –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω ‚Äî –Ω–∞—á–∏–Ω–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å
        await message.answer(
            "üîó <b>–ü—Ä–∏–≤—è–∑–∫–∞ Steam</b>\n\n"
            "–ü—Ä–∏—à–ª–∏ –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ —Ç–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å Steam –∏–ª–∏ —Ç–≤–æ–π Steam ID.\n"
            "<i>–ü—Ä–∏–º–µ—Ä: https://steamcommunity.com/id/gaben/</i>",
            reply_markup=get_onboarding_kb(),
            parse_mode="HTML"
        )
        await state.set_state(UserStates.waiting_for_steam_link)

@router.message(UserStates.waiting_for_steam_link)
async def process_steam_link(message: types.Message, state: FSMContext, session: AsyncSession):
    input_text = message.text.strip()
    
    # 1. –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å ID
    steam_id = await steam_service.resolve_vanity_url(input_text)
    
    if not steam_id:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç–∞–∫–æ–π –ø—Ä–æ—Ñ–∏–ª—å. –ü—Ä–æ–≤–µ—Ä—å —Å—Å—ã–ª–∫—É.")
        return

    # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –∏–≥—Ä (–ü—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—å)
    await message.answer("‚è≥ –ü—Ä–æ–≤–µ—Ä—è—é –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏...")
    games = await steam_service.get_owned_games(steam_id)
    
    if games is None:
        await message.answer(
            "üîí <b>–ü—Ä–æ—Ñ–∏–ª—å —Å–∫—Ä—ã—Ç!</b>\n\n"
            "–Ø –Ω–µ –≤–∏–∂—É —Ç–≤–æ–∏ –∏–≥—Ä—ã. –û—Ç–∫—Ä–æ–π –∏—Ö –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö Steam:\n"
            "<i>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ—Ñ–∏–ª—å -> –ü—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—å -> –î–æ—Å—Ç—É–ø –∫ –∏–≥—Ä–∞–º: –û—Ç–∫—Ä—ã—Ç—ã–π</i>\n\n"
            "–ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –ø—Ä–∏—à–ª–∏ —Å—Å—ã–ª–∫—É –µ—â–µ —Ä–∞–∑.",
            parse_mode="HTML"
        )
        return

    # 3. –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ –æ —é–∑–µ—Ä–µ (–Ω–∏–∫, –∞–≤–∞—Ç–∞—Ä)
    player_summary = await steam_service.get_player_summary(steam_id)
    username = player_summary.get('personaname', 'Unknown')
    avatar = player_summary.get('avatarfull')

    # 4. –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
    repo = UserRepo(session)
    await repo.create_or_update(
        telegram_id=message.from_user.id,
        steam_id=int(steam_id),
        username=username,
        avatar=avatar
    )
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫—É (—ç—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è, –≤ –∏–¥–µ–∞–ª–µ –¥–µ–ª–∞—Ç—å —Ñ–æ–Ω–æ–º, –Ω–æ –ø–æ–∫–∞ —Ç–∞–∫)
    await repo.update_library(message.from_user.id, games)

    await state.clear()
    await message.answer(
        f"‚úÖ <b>–£—Å–ø–µ—à–Ω–æ!</b>\n"
        f"üë§ –ù–∏–∫: {username}\n"
        f"üéÆ –ò–≥—Ä –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫–µ: {len(games)}\n\n"
        "–¢–µ–ø–µ—Ä—å —è –∑–Ω–∞—é, –≤–æ —á—Ç–æ —Ç—ã –∏–≥—Ä–∞–µ—à—å!",
        parse_mode="HTML"
    )import logging
from aiogram import Router, types, F
from aiogram.types import InputMediaPhoto, InputMediaVideo
from aiogram.enums import ParseMode
from sqlalchemy.ext.asyncio import AsyncSession

from database.repo.games import GameRepo
from keyboards.pagination import get_media_pagination, get_info_pagination

router = Router()

# === –õ–û–ì–ò–ö–ê –û–¢–û–ë–†–ê–ñ–ï–ù–ò–Ø ===

async def send_game_interface(message: types.Message, game):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏–≥—Ä—ã: –ú–µ–¥–∏–∞ + –ò–Ω—Ñ–æ"""
    
    # 1. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ú–µ–¥–∏–∞ (–ì–ª–∞–≤–Ω–∞—è –∫–∞—Ä—Ç–∏–Ω–∫–∞)
    header_url = game.locales.get('ru', {}).get('header_image') or \
                 game.locales.get('en', {}).get('header_image') or \
                 game.extra_data.get('header_image')

    # –°—á–∏—Ç–∞–µ–º —Å–∫–æ–ª—å–∫–æ –≤—Å–µ–≥–æ —Å–ª–∞–π–¥–æ–≤ (—Å–∫—Ä–∏–Ω—à–æ—Ç—ã + –≤–∏–¥–µ–æ)
    screenshots = game.extra_data.get('screenshots', [])
    movies = game.extra_data.get('movies', [])
    total_media = len(screenshots) + len(movies)

    # –ö–Ω–æ–ø–∫–∏ –¥–ª—è –º–µ–¥–∏–∞ (–Ω–∞—á–∏–Ω–∞–µ–º —Å –∏–Ω–¥–µ–∫—Å–∞ -1, —ç—Ç–æ Header)
    media_kb = get_media_pagination(game.id, -1, total_media, "image")
    
    await message.answer_photo(
        photo=header_url,
        caption="üñº <b>–ì–∞–ª–µ—Ä–µ—è</b> (–õ–∏—Å—Ç–∞–π –∫–Ω–æ–ø–∫–∞–º–∏)",
        reply_markup=media_kb,
        parse_mode=ParseMode.HTML
    )

    # 2. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ò–Ω—Ñ–æ (–°—Ç—Ä–∞–Ω–∏—Ü–∞ 1)
    info_text = get_page_text(game, 1)
    info_kb = get_info_pagination(game.id, 1, 3) # –í—Å–µ–≥–æ 3 —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏–Ω—Ñ—ã
    
    await message.answer(
        text=info_text,
        reply_markup=info_kb,
        parse_mode=ParseMode.HTML,
        disable_web_page_preview=True
    )

# === –ì–ï–ù–ï–†–ê–¢–û–† –¢–ï–ö–°–¢–ê –°–¢–†–ê–ù–ò–¶ ===

def get_page_text(game, page: int) -> str:
    loc = game.locales.get('ru') or game.locales.get('en') or {}
    
    if page == 1:
        # –°–¢–†–ê–ù–ò–¶–ê 1: –û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ
        price = f"{game.price_current} $" if game.price_current else "–ë–µ—Å–ø–ª–∞—Ç–Ω–æ/–ù–µ–∏–∑–≤."
        time_100 = f"~{game.time_100} —á." if game.time_100 else "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        meta = game.metacritic_score or "–ù–µ—Ç"
        
        return (
            f"üéÆ <b>{game.name}</b>\n"
            f"‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
            f"üìÖ <b>–î–∞—Ç–∞ –≤—ã—Ö–æ–¥–∞:</b> {game.release_date}\n"
            f"üí∞ <b>–¶–µ–Ω–∞:</b> {price}\n"
            f"‚≠êÔ∏è <b>Metacritic:</b> {meta}\n"
            f"‚è± <b>–í—Ä–µ–º—è –Ω–∞ 100%:</b> {time_100}\n"
            f"üèÜ <b>–ê—á–∏–≤–æ–∫:</b> {game.achievements_count}\n"
            f"üë• <b>–û—Ç–∑—ã–≤–æ–≤:</b> {game.reviews_total:,}"
        )
    
    elif page == 2:
        # –°–¢–†–ê–ù–ò–¶–ê 2: –û–ø–∏—Å–∞–Ω–∏–µ
        # –û—á–∏—â–∞–µ–º HTML —Ç–µ–≥–∏ (–ø—Ä–æ—Å—Ç–æ, –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞)
        desc = loc.get('short_desc') or "–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç."
        # –ï—Å–ª–∏ –µ—Å—Ç—å –¥–µ—Ç–∞–ª—å–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ, –º–æ–∂–Ω–æ –≤–∑—è—Ç—å –∫—É—Å–æ–∫ –æ—Ç—Ç—É–¥–∞
        return f"üìù <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b>\n\n{desc}"
    
    elif page == 3:
        # –°–¢–†–ê–ù–ò–¶–ê 3: –°–∏—Å—Ç–µ–º–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è –∏ –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏
        devs = ", ".join(game.extra_data.get('developers', []))
        reqs = game.extra_data.get('pc_requirements', {})
        min_req = reqs.get('minimum', '–ù–µ —É–∫–∞–∑–∞–Ω—ã')
        
        # –ß–∏—Å—Ç–∏–º HTML –≤ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è—Ö (–æ—á–µ–Ω—å –≥—Ä—É–±–æ, –ª—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å BeautifulSoup)
        min_req = min_req.replace("<br>", "\n").replace("<strong>", "").replace("</strong>", "")
        
        return (
            f"üõ† <b>–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –∏–Ω—Ñ–æ:</b>\n\n"
            f"üë®‚Äçüíª <b>–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏:</b> {devs}\n\n"
            f"‚öôÔ∏è <b>–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è:</b>\n{min_req[:500]}..." # –û–±—Ä–µ–∑–∞–µ–º, –µ—Å–ª–∏ –¥–ª–∏–Ω–Ω–æ
        )
    
    return "–û—à–∏–±–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã"

# === –•–ï–ù–î–õ–ï–†–´ –ü–ï–†–ï–ö–õ–Æ–ß–ï–ù–ò–Ø ===

# 1. –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –ú–ï–î–ò–ê
@router.callback_query(F.data.startswith("media_"))
async def callback_media(callback: types.CallbackQuery, session: AsyncSession):
    # data: media_GAMEID_INDEX
    parts = callback.data.split("_")
    game_id = int(parts[1])
    index = int(parts[2])
    
    repo = GameRepo(session)
    game = await repo.get_by_id(game_id)
    if not game: return

    # –î–æ—Å—Ç–∞–µ–º —Å–ø–∏—Å–∫–∏
    screenshots = game.extra_data.get('screenshots', [])
    movies = game.extra_data.get('movies', [])
    total = len(screenshots) + len(movies)

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º, —á—Ç–æ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å
    media_obj = None
    
    if index == -1:
        # –ì–ª–∞–≤–Ω–∞—è –∫–∞—Ä—Ç–∏–Ω–∫–∞
        url = game.locales.get('ru', {}).get('header_image') or game.extra_data.get('header_image')
        media_obj = InputMediaPhoto(media=url, caption="üñº <b>–ì–∞–ª–µ—Ä–µ—è</b>")
    
    elif 0 <= index < len(screenshots):
        # –°–∫—Ä–∏–Ω—à–æ—Ç
        url = screenshots[index]
        media_obj = InputMediaPhoto(media=url, caption=f"üì∏ –°–∫—Ä–∏–Ω—à–æ—Ç {index+1}")
        
    elif index >= len(screenshots):
        # –í–∏–¥–µ–æ
        vid_index = index - len(screenshots)
        url = movies[vid_index]
        # –í–∞–∂–Ω–æ: –í–∏–¥–µ–æ –º–æ–∂–µ—Ç –Ω–µ –≥—Ä—É–∑–∏—Ç—å—Å—è, –µ—Å–ª–∏ —Ñ–æ—Ä–º–∞—Ç –Ω–µ —Ç–æ—Ç. 
        # Steam —á–∞—Å—Ç–æ –¥–∞–µ—Ç .webm, –∫–æ—Ç–æ—Ä—ã–π –¢–µ–ª–µ–≥—Ä–∞–º –Ω–µ –ª—é–±–∏—Ç. –õ—É—á—à–µ –∏—Å–∫–∞—Ç—å .mp4
        media_obj = InputMediaVideo(media=url, caption=f"üé• –¢—Ä–µ–π–ª–µ—Ä {vid_index+1}")

    # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    try:
        kb = get_media_pagination(game_id, index, total, "mixed")
        await callback.message.edit_media(media=media_obj, reply_markup=kb)
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –º–µ–¥–∏–∞: {e}")
        await callback.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–µ–¥–∏–∞ (–≤–æ–∑–º–æ–∂–Ω–æ, —Ñ–æ—Ä–º–∞—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è).")

# 2. –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –ò–ù–§–û (–°—Ç—Ä–∞–Ω–∏—Ü—ã)
@router.callback_query(F.data.startswith("info_"))
async def callback_info(callback: types.CallbackQuery, session: AsyncSession):
    # data: info_GAMEID_PAGE
    parts = callback.data.split("_")
    game_id = int(parts[1])
    page = int(parts[2])
    
    repo = GameRepo(session)
    game = await repo.get_by_id(game_id)
    
    if not game: return

    text = get_page_text(game, page)
    kb = get_info_pagination(game_id, page, 3)
    
    # edit_text, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    try:
        await callback.message.edit_text(text, reply_markup=kb, parse_mode=ParseMode.HTML, disable_web_page_preview=True)
    except Exception:
        await callback.answer() # –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è

# 3. –í—Ö–æ–¥–Ω–∞—è —Ç–æ—á–∫–∞ (–∏–∑ –ø–æ–∏—Å–∫–∞)
@router.callback_query(F.data.startswith("view_game_"))
async def callback_view_game_entry(callback: types.CallbackQuery, session: AsyncSession):
    game_id = int(callback.data.split("_")[2])
    repo = GameRepo(session)
    game = await repo.get_by_id(game_id)
    
    if game:
        await callback.message.delete()
        await send_game_interface(callback.message, game)
    else:
        await callback.answer("–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")# –§–∞–π–ª: steam_bot/handlers/base.py

from aiogram import Router, types, F
from aiogram.filters import CommandStart
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from keyboards.main_menu import get_main_menu
from database.repo.users import UserRepo

router = Router()

@router.message(CommandStart())
async def cmd_start(message: types.Message, state: FSMContext, session: AsyncSession):
    await state.clear() # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ª—é–±—ã–µ —Å—Ç–∞—Ä—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    
    user_repo = UserRepo(session)
    user = await user_repo.get_user(message.from_user.id)
    
    if user and user.steam_id:
        # –ï—Å–ª–∏ —é–∑–µ—Ä —É–∂–µ –µ—Å—Ç—å –≤ –±–∞–∑–µ
        await message.answer(
            f"üëã –° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º, <b>{user.username or message.from_user.first_name}</b>!\n"
            "–¢—ã –º–æ–∂–µ—à—å –∏—Å–∫–∞—Ç—å –∏–≥—Ä—ã –∏–ª–∏ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å.",
            reply_markup=get_main_menu(),
            parse_mode="HTML"
        )
    else:
        # –ï—Å–ª–∏ –Ω–æ–≤–µ–Ω—å–∫–∏–π
        await message.answer(
            "üëã <b>–ü—Ä–∏–≤–µ—Ç! –Ø Steam Explorer.</b>\n\n"
            "–Ø –ø–æ–º–æ–≥—É —Ç–µ–±–µ:\n"
            "üîπ –°–ª–µ–¥–∏—Ç—å –∑–∞ –∞—á–∏–≤–∫–∞–º–∏\n"
            "üîπ –ò—Å–∫–∞—Ç—å –∏–≥—Ä—ã (–¥–∞–∂–µ –µ—Å–ª–∏ —Ç—ã –∑–∞–±—ã–ª –Ω–∞–∑–≤–∞–Ω–∏–µ)\n"
            "üîπ –£–∑–Ω–∞—Ç—å –≤—Ä–µ–º—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è\n\n"
            "–ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å, –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É <b>'üë§ –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å'</b> –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã.",
            reply_markup=get_main_menu(),
            parse_mode="HTML"
        )import asyncio
import aiohttp
import json
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from sqlalchemy import select, update
from database.models import Game # –£–±–µ–¥–∏—Å—å, —á—Ç–æ –ø—É—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π
from config import conf

TARGET_ID = 1222140 # Detroit: Become Human

async def fetch_store_data(app_id):
    url = f"https://store.steampowered.com/api/appdetails?appids={app_id}&cc=ru&l=russian"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            if resp.status == 200:
                data = await resp.json()
                if data[str(app_id)]['success']:
                    return data[str(app_id)]['data']
    return None

async def update_game():
    print(f"üöÄ –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è Detroit (ID: {TARGET_ID})...")
    
    data = await fetch_store_data(TARGET_ID)
    if not data:
        print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ Steam.")
        return

    # 1. –°–æ–±–∏—Ä–∞–µ–º –º–µ–¥–∏–∞ (–°–∫—Ä–∏–Ω—à–æ—Ç—ã + –í–∏–¥–µ–æ)
    screenshots = [s['path_full'] for s in data.get('screenshots', [])]
    movies = []
    if 'movies' in data:
        for m in data['movies']:
            # –ë–µ—Ä–µ–º mp4 –≤ 480p (—á—Ç–æ–±—ã —Ç–µ–ª–µ–≥—Ä–∞–º –±—ã—Å—Ç—Ä–æ –≥—Ä—É–∑–∏–ª)
            if 'mp4' in m:
                movies.append(m['mp4'].get('480', m['mp4'].get('max')))
    
    # 2. –°–æ–±–∏—Ä–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ
    locales = {
        "ru": {
            "short_desc": data.get('short_description'),
            "detailed_desc": data.get('detailed_description'), # HTML –æ–ø–∏—Å–∞–Ω–∏–µ
            "header_image": data.get('header_image')
        }
    }

    # 3. –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
    extra_data = {
        "screenshots": screenshots,
        "movies": movies,
        "developers": data.get('developers'),
        "publishers": data.get('publishers'),
        "metacritic": data.get('metacritic', {}).get('score'),
        "pc_requirements": data.get('pc_requirements', {})
    }

    # 4. –ó–∞–ø–∏—Å—å –≤ –ë–î
    engine = create_async_engine(conf.database_url, echo=False)
    async_session = sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)

    async with async_session() as session:
        result = await session.execute(select(Game).where(Game.id == TARGET_ID))
        game = result.scalars().first()

        if not game:
            print("–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –±–∞–∑–µ, —Å–æ–∑–¥–∞—é...")
            game = Game(id=TARGET_ID, name=data['name'])
            session.add(game)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—è
        game.price_current = data.get('price_overview', {}).get('final', 0) / 100
        game.metacritic_score = extra_data['metacritic'] or 0
        game.locales = locales
        game.extra_data = extra_data
        
        await session.commit()
        print("‚úÖ –î–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã! –°–∫—Ä–∏–Ω—à–æ—Ç–æ–≤:", len(screenshots), "–í–∏–¥–µ–æ:", len(movies))

    await engine.dispose()

if __name__ == "__main__":
    asyncio.run(update_game())